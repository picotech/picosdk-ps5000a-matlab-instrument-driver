<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>picotech_ps5000a_generic.mdd</DriverName>
   <DriverType>MATLAB generic</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Pico Technology Ltd.</InstrumentManufacturer>
   <InstrumentModel>PicoScope 5000A, 5000B and 5000D Series</InstrumentModel>
   <InstrumentVersion>2.2.17.59</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright © 2013-2019 Pico Technology Ltd. All rights reserved. 
% You may copy and distribute this file as long as it remains unmodified. 
% SB
    
    fprintf('PicoScope 5000 Series (A API) MATLAB Instrument Driver');
    fprintf('\n');
    fprintf('\nCopyright © 2013-2019 Pico Technology Ltd. All rights reserved.\n');
    fprintf('\n');

    % Load libraries
    % ==============
    
    % Indentify architecture and obtain function handle for the correct
    % prototype file.
    
    archStr = computer('arch');
    
    ps5000aMFile = str2func(strcat('ps5000aMFile_', archStr));
    ps5000aWrapMFile = str2func(strcat('ps5000aWrapMFile_', archStr));
    
    % Suppress warnings of functions that are not found
    warning('off','MATLAB:loadlibrary:FunctionNotFound');
    
    % Only load library once 
    if (libisloaded('ps5000a'))
       
        % Do nothing
        
    else
        
        if (ismac())
            
            [ps5000aNotFound, ps5000aWarnings] = loadlibrary('libps5000a.dylib', ps5000aMFile, 'alias', 'ps5000a');
            
        elseif (isunix())
            
            [ps5000aNotFound, ps5000aWarnings] = loadlibrary('libps5000a.so', ps5000aMFile, 'alias', 'ps5000a');
        
        elseif (ispc())
            
            [ps5000aNotFound, ps5000aWarnings] = loadlibrary('ps5000a.dll', ps5000aMFile);
            
        else
            
            % Do nothing
            
        end
        
    end
    
    % Check if the library still has not loaded
    if ~libisloaded('ps5000a')
        
        error('PS5000aCreate:LibraryNotFound', ['ps5000a shared library or ', func2str(ps5000aMFile), ' not found - please check the MATLAB Path.']); 
        
    end

    % ps5000aWrapMFile_archStr.m contains duplicate enumerations and
    % structures from ps5000aMFile_archStr.m

    warning('off','MATLAB:loadlibrary:EnumExists');
    warning('off','MATLAB:loadlibrary:StructTypeExists');
    
    % Only load library once 
    if (libisloaded('ps5000aWrap'))

        % Do nothing
        
    else
        
        if (ismac())
            
            [ps5000aWrapNotFound, ps5000aWrapWarnings] = loadlibrary('libps5000aWrap.dylib', ps5000aWrapMFile, 'alias', 'ps5000aWrap');
        
        elseif (isunix())
            
            [ps5000aWrapNotFound, ps5000aWrapWarnings] = loadlibrary('libps5000aWrap.so', ps5000aWrapMFile, 'alias', 'ps5000aWrap');

        elseif (ispc())
            
            [ps5000aWrapNotFound, ps5000aWrapWarnings] = loadlibrary('ps5000aWrap.dll', ps5000aWrapMFile);
            
        else
            
            % Do nothing
            
        end
        
    end
    
    %check if the library still has not loaded
    if ~libisloaded('ps5000aWrap')
        
        error('PS5000aCreate:LibraryNotFound', ['ps5000aWrap shared library or ', func2str(ps5000aWrapMFile), ' not found - please check the MATLAB Path.']);  
        
    end
    
    % Load in enumeration and structure information
    % =============================================
    
    [~, obj.DriverData.structs, obj.DriverData.enums, ~] = ps5000aMFile(); 
    [~, ~, obj.DriverData.wrapEnums, ~] = ps5000aWrapMFile();
    
    % Define constant values used by this Instrument Driver
    % =====================================================
    
    % Constants from ps5000aApi.h header file
    % ---------------------------------------
    
    % ADC Counts
    obj.DriverData.constants.PS5000A_MAX_VALUE_8BIT      = 32512;
    obj.DriverData.constants.PS5000A_MIN_VALUE_8BIT      = -32512;

    obj.DriverData.constants.PS5000A_MAX_VALUE_16BIT     = 32767;
    obj.DriverData.constants.PS5000A_MIN_VALUE_16BIT     = -32767;

    obj.DriverData.constants.PS5000A_EXT_MAX_VALUE = 32767;
    obj.DriverData.constants.PS5000A_EXT_MIN_VALUE = -32767;

    obj.DriverData.constants.PS5000A_EXT_MAX_VOLTAGE = 5; % Max threshold, volts
    obj.DriverData.constants.PS5000A_EXT_MIN_VOLTAGE = -5; % Min threshold, volts
    
    % MSO Properties
    obj.DriverData.constants.PS5000A_MAX_LOGIC_LEVEL	= 32767;
    obj.DriverData.constants.PS5000A_MIN_LOGIC_LEVEL    = -32767;

    obj.DriverData.constants.PS5000A_MAX_LOGIC_VOLTAGE  = 5;
    obj.DriverData.constants.PS5000A_MIN_LOGIC_VOLTAGE  = -5;
    
    % ETS Information
    obj.DriverData.constants.PS5244A_MAX_ETS_CYCLES      = 500;		% PS5242A, PS5242B, PS5442A, PS5442B
    obj.DriverData.constants.PS5244A_MAX_ETS_INTERLEAVE  = 40;

    obj.DriverData.constants.PS5243A_MAX_ETS_CYCLES      = 250;		% PS5243A, PS5243B, PS5443A, PS5443B
    obj.DriverData.constants.PS5243A_MAX_ETS_INTERLEAVE  = 20;

    obj.DriverData.constants.PS5242A_MAX_ETS_CYCLES      = 125;      % PS5242A, PS5242B, PS5442A, PS5442B
    obj.DriverData.constants.PS5242A_MAX_ETS_INTERLEAVE  = 10;

    obj.DriverData.constants.PS5X44D_MAX_ETS_CYCLES      = 500;      % PS5244D, PS5244DMSO, PS5444D, PS5444DMSO
    obj.DriverData.constants.PS5X44D_MAX_ETS_INTERLEAVE  = 80;

    obj.DriverData.constants.PS5X43D_MAX_ETS_CYCLES      = 250;    	% PS5243D, PS5243DMSO, PS5443D, PS5443DMSO
    obj.DriverData.constants.PS5X43D_MAX_ETS_INTERLEAVE  = 40;

    obj.DriverData.constants.PS5X42D_MAX_ETS_CYCLES      = 125;    	% PS5242D, PS5242DMSO, PS5442D, PS5442DMSO
    obj.DriverData.constants.PS5X42D_MAX_ETS_INTERLEAVE  = 5;

    % Trigger information
    obj.DriverData.constants.MAX_PULSE_WIDTH_QUALIFIER_COUNT = 16777215;
    obj.DriverData.constants.MAX_DELAY_COUNT                 = 8388607;

    % Function/Arbitrary Waveform parameters
    obj.DriverData.constants.MIN_SIG_GEN_FREQ = 0.0;
    obj.DriverData.constants.MAX_SIG_GEN_FREQ = 20000000.0;

    obj.DriverData.constants.PS5X42A_MAX_SIG_GEN_BUFFER_SIZE = 16384;    % Covers the 5242A/B and 5442A/B
    obj.DriverData.constants.PS5X43A_MAX_SIG_GEN_BUFFER_SIZE = 32768;    % Covers the 5243A/B and 5443A/B
    obj.DriverData.constants.PS5X44A_MAX_SIG_GEN_BUFFER_SIZE = 49152;    % Covers the 5244A/B and 5444A/B

    obj.DriverData.constants.PS5X4XD_MAX_SIG_GEN_BUFFER_SIZE = 32768;    % Covers the PicoScope 5000D Series

    obj.DriverData.constants.MIN_SIG_GEN_BUFFER_SIZE         = 1;
    obj.DriverData.constants.MIN_DWELL_COUNT                 = 3;
    obj.DriverData.constants.MAX_SWEEPS_SHOTS				= pow2(30) - 1; % 1073741823
    obj.DriverData.constants.AWG_DAC_FREQUENCY				= PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
    obj.DriverData.constants.PS5000AB_DDS_FREQUENCY 			= 200e6;
    obj.DriverData.constants.PS5000D_DDS_FREQUENCY 			= 100e6;
    obj.DriverData.constants.AWG_PHASE_ACCUMULATOR           = 4294967296.0;

    PS5000A_SHOT_SWEEP_TRIGGER_CONTINUOUS_RUN = hex2dec('FFFFFFFF');
    
    % Analogue offset information
    obj.DriverData.constants.MAX_ANALOGUE_OFFSET_50MV_200MV = 0.250;
    obj.DriverData.constants.MIN_ANALOGUE_OFFSET_50MV_200MV = -0.250;
    obj.DriverData.constants.MAX_ANALOGUE_OFFSET_500MV_2V   = 2.500;
    obj.DriverData.constants.MIN_ANALOGUE_OFFSET_500MV_2V   = -2.500;
    obj.DriverData.constants.MAX_ANALOGUE_OFFSET_5V_20V     = 20;
    obj.DriverData.constants.MIN_ANALOGUE_OFFSET_5V_20V	   = -20;

    % Signal generator frequencies
    PS5000A_SINE_MAX_FREQUENCY		= 20000000;
    PS5000A_SQUARE_MAX_FREQUENCY	= 20000000;
    PS5000A_TRIANGLE_MAX_FREQUENCY	= 20000000;
    PS5000A_SINC_MAX_FREQUENCY		= 20000000;
    PS5000A_RAMP_MAX_FREQUENCY		= 20000000;
    PS5000A_HALF_SINE_MAX_FREQUENCY	= 20000000;
    PS5000A_GAUSSIAN_MAX_FREQUENCY  = 20000000;
    PS5000A_PRBS_MAX_FREQUENCY		= 1000000;
    PS5000A_PRBS_MIN_FREQUENCY		= 0.03;
    PS5000A_MIN_FREQUENCY			= 0.03;
    
    % Maximum number of devices using this driver
    % -------------------------------------------
    
    obj.DriverData.constants.PS5000A_MAX_UNITS = 64;
    
    
    % PicoScope 5000 Series models using the 'A' API
    % ----------------------------------------------
    
    % 2-channel variants
    obj.DriverData.constants.MODEL_PS5242A   = '5242A';
    obj.DriverData.constants.MODEL_PS5242B   = '5242B';
    obj.DriverData.constants.MODEL_PS5243A   = '5243A';
    obj.DriverData.constants.MODEL_PS5243B   = '5243B';
    obj.DriverData.constants.MODEL_PS5244A   = '5244A';
    obj.DriverData.constants.MODEL_PS5244B   = '5244B';
    obj.DriverData.constants.MODEL_PS5242D   = '5242D';
    obj.DriverData.constants.MODEL_PS5243D   = '5243D';
    obj.DriverData.constants.MODEL_PS5244D   = '5244D';

    % 2-channel MSO models
    obj.DriverData.constants.MODEL_PS5242D_MSO   = '5242DMSO';
    obj.DriverData.constants.MODEL_PS5243D_MSO   = '5243DMSO';
    obj.DriverData.constants.MODEL_PS5244D_MSO   = '5244DMSO';

    % 4-channel variants
    obj.DriverData.constants.MODEL_PS5442A   = '5442A';
    obj.DriverData.constants.MODEL_PS5442B   = '5442B';
    obj.DriverData.constants.MODEL_PS5443A   = '5443A';
    obj.DriverData.constants.MODEL_PS5443B   = '5443B';
    obj.DriverData.constants.MODEL_PS5444A   = '5444A';
    obj.DriverData.constants.MODEL_PS5444B   = '5444B';
    obj.DriverData.constants.MODEL_PS5442D   = '5442D';
    obj.DriverData.constants.MODEL_PS5443D   = '5443D';
    obj.DriverData.constants.MODEL_PS5444D   = '5444D';
    obj.DriverData.constants.MODEL_PS5444B_034 = '5444B/034';

    % 4-channel MSO models
    obj.DriverData.constants.MODEL_PS5442D_MSO   = '5442DMSO';
    obj.DriverData.constants.MODEL_PS5443D_MSO   = '5443DMSO';
    obj.DriverData.constants.MODEL_PS5444D_MSO   = '5444DMSO';
    
    % Obtain flag to indicate if functions should output text to Command
    % Window
    % -------------------------------
    
    obj.DriverData.displayOutput = obj.displayOutput;
    
    
    % Enumerate units 
    % ---------------
    
    % Only displayed if driver is being used via command line
    
    count = int16(0);
    serials = blanks(100);
    serialLth = int16(100);
    
    [status, count, serials, serialLth] = calllib('ps5000a', ...
        'ps5000aEnumerateUnits',  count, serials, serialLth);
    
    if (status == PicoStatus.PICO_OK)
        
        fprintf('Number of units found: %d\n\nSerial number(s): %s\n\n', count, serials);
        
    elseif (status == PicoStatus.PICO_NOT_FOUND)
        
        error('PS5000aCreate:NoUnitsFound', 'No units found.');
        
    else
        
        error('PS5000aCreate:EnumerateError', 'Status code: %d\n', status);
        
    end
    </Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright © 2013-2019 Pico Technology Ltd. All rights reserved.
% You may copy and distribute this file as long as it remains unmodified.
% SB

    disp('Opening PicoScope 5000 Series (A API) device...');

    % Structure to hold status values while connecting to the device.
    % Only output when the driver is called using command line or script.
    connectStatus = [];

    % Temporary variable to store handle value
    unitHandle = 0;
    
    % PICO_OK status value (0)
    picoOK = PicoStatus.PICO_OK;

    % Obtain the serial input
    serialNum = get(obj, 'RsrcName');

    % Determine if serial number is specified or null
    if length(serialNum) &gt; 0

        unitSerial = serialNum;

    else

        unitSerial = [];

    end
    
    % Initial channel settings to assist with change in power source
    % Setup initial channel settings (4 x 4)
    % 4 channels consisting of enabled, coupling, range, analogue offset
    % Default will be set later via resetDevice
    
    obj.DriverData.channelSettings = zeros(PicoConstants.QUAD_SCOPE, 4);

    % Initialise matrix for digital port settings
    % Setup initial channel settings (2 x 2)
    % 2 channels consisting of enabled state and logic level
    % Default will be set later via resetDevice
    
    obj.DriverData.digitalPortSettings = zeros(PicoConstants.DUAL_SCOPE, 2);
    
    % Default resolution set to 8 bits
    resolution8bit = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_8BIT;
    obj.DriverData.resolution = 8;

    % Open the unit
    [connectStatus.openUnit, obj.DriverData.unitHandle, ~] = ...
        calllib('ps5000a', 'ps5000aOpenUnit', unitHandle, unitSerial, resolution8bit);
    
    % Confirm handle is valid
    if (obj.DriverData.unitHandle &gt; 0)
    
        unitHandle = obj.DriverData.unitHandle;
        
        % Set serial 
        infoLine = blanks(40);
        reqSize = length(infoLine);

        [connectStatus.unitSerial, obj.DriverData.unitSerial, reqSize]  = calllib('ps5000a', ...
                'ps5000aGetUnitInfo', unitHandle, infoLine, ... 
                length(infoLine), reqSize, PicoStatus.PICO_BATCH_AND_SERIAL);

        % Set variant and channel count information
        infoLineV = blanks(15);
        reqSizeV = 15;
        
        [connectStatus.unitVariant, variant, ~]  = calllib('ps5000a', ...
                'ps5000aGetUnitInfo', unitHandle, infoLineV, ... 
                length(infoLineV), reqSizeV, PicoStatus.PICO_VARIANT_INFO);

        set(obj, 'InstrumentModel', variant);
        
        % Obtain channel count
        obj.DriverData.channelCount = str2num(obj.InstrumentModel(2));
        
        % Check power settings
        powerStatus = PicoStatus.PICO_OK;
        
        % Power supply not connected or 2-channel 5000D device on non-USB 3.0
        % port
        if (connectStatus.openUnit == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED || ...
                connectStatus.openUnit == PicoStatus.PICO_USB3_0_DEVICE_NON_USB3_0_PORT) 

            powerStatus = invoke(obj, 'ps5000aChangePowerSource', connectStatus.openUnit);

        end

        % Unit connected if PICO_OK or power supply not connected 
        if (connectStatus.openUnit == picoOK || powerStatus == picoOK)

            % Display object information
            obj

            % Set Device Properties
            % ---------------------

            % Set the number of analogue channels and digital ports on the device in the wrapper
            status = calllib('ps5000aWrap', 'setChannelCount', unitHandle, obj.DriverData.channelCount);

            % Max/min voltage ranges
            range10mV   = obj.DriverData.enums.enPS5000ARange.PS5000A_10MV;
            range20V    = obj.DriverData.enums.enPS5000ARange.PS5000A_20V;

            % Set the max. ADC value
            maxValPtr = libpointer('int16Ptr', 0);

            [maxValueStatus, ~]  = calllib('ps5000a', 'ps5000aMaximumValue', unitHandle, maxValPtr);

            obj.DriverData.maxADCValue = maxValPtr.Value;

            clear maxValPtr;
            clear maxValueStatus;

            % Set the min. ADC value 
            minValPtr = libpointer('int16Ptr', 0);

            [minValueStatus, ~] = calllib('ps5000a', 'ps5000aMinimumValue', unitHandle, minValPtr);

            obj.DriverData.minADCValue = minValPtr.Value;

            clear minValPtr;
            clear minValueStatus;

            % Max. sampling rate
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;

            % Set bandwidth and buffer memory information
            switch(obj.InstrumentModel)

                case {obj.DriverData.constants.MODEL_PS5242A, obj.DriverData.constants.MODEL_PS5442A}

                    obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_16MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;

                case {obj.DriverData.constants.MODEL_PS5242B, obj.DriverData.constants.MODEL_PS5442B}

                    obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
                    
                case {obj.DriverData.constants.MODEL_PS5242D, obj.DriverData.constants.MODEL_PS5242D_MSO, ...
                         obj.DriverData.constants.MODEL_PS5442D, obj.DriverData.constants.MODEL_PS5442D_MSO}
                     
                    obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_60MHZ; 

                case {obj.DriverData.constants.MODEL_PS5243A, obj.DriverData.constants.MODEL_PS5443A}

                    obj.DriverData.hasHardwareEts = PicoConstants.TRUE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_64MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;

                case {obj.DriverData.constants.MODEL_PS5243B, obj.DriverData.constants.MODEL_PS5443B}

                    obj.DriverData.hasHardwareEts = PicoConstants.TRUE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                    
                case {obj.DriverData.constants.MODEL_PS5243D, obj.DriverData.constants.MODEL_PS5243D_MSO, ... 
                        obj.DriverData.constants.MODEL_PS5443D, obj.DriverData.constants.MODEL_PS5443D_MSO}
                    
                    obj.DriverData.hasHardwareEts = PicoConstants.TRUE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;

                case {obj.DriverData.constants.MODEL_PS5244A, obj.DriverData.constants.MODEL_PS5444A}

                    obj.DriverData.hasHardwareEts = PicoConstants.TRUE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;

                case {obj.DriverData.constants.MODEL_PS5244B, obj.DriverData.constants.MODEL_PS5444B, ...
                        obj.DriverData.constants.MODEL_PS5244D, obj.DriverData.constants.MODEL_PS5244D_MSO, ... 
                        obj.DriverData.constants.MODEL_PS5444D, obj.DriverData.constants.MODEL_PS5444D_MSO, ...
                        obj.DriverData.constants.MODEL_PS5444B_034}

                    obj.DriverData.hasHardwareEts = PicoConstants.TRUE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_512MS;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;

                otherwise

                    obj.DriverData.channelCount = 0;
                    obj.DriverData.digitalPorts = 0;
                    obj.DriverData.firstRange = range10mV;
                    obj.DriverData.lastRange = range20V;
                    obj.DriverData.sigGenType = PicoConstants.SIG_GEN_NONE;
                    obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                    obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                    obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                    obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_ZERO;
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_ZERO;
                    obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_ZERO;

                    % Close the connection to the device, then report an
                    % error.
                    disconnect(obj);
                    error('Picotech:PS5000AInstrumentDriver:UnitNotSupported', ...
                    'Connect: This device is not supported by the Instrument Driver.');

            end

            % Determine if device is an MSO
            obj.DriverData.digitalPortCount = 0;
            obj.DriverData.maxLogicLevel = 0;
            obj.DriverData.minLogicLevel = 0;

            isMSO = strfind(obj.InstrumentModel, 'MSO');

            if (~isempty(isMSO))

                obj.DriverData.digitalPortCount = 2;
                obj.DriverData.maxLogicLevel = obj.DriverData.constants.PS5000A_MAX_LOGIC_LEVEL;
                obj.DriverData.minLogicLevel = obj.DriverData.constants.PS5000A_MIN_LOGIC_LEVEL;

            end

            pMinArbitraryValue = libpointer('int16Ptr', 0);
            pMaxArbitraryValue = libpointer('int16Ptr', 0);
            pMinArbitraryBufferSize = libpointer('uint32Ptr', 0);
            pMaxArbitraryBufferSize = libpointer('uint32Ptr', 0); 

            [status, ~, ~, ~, ~] = calllib('ps5000a', 'ps5000aSigGenArbitraryMinMaxValues', ...
                                    unitHandle, pMinArbitraryValue, pMaxArbitraryValue, pMinArbitraryBufferSize, pMaxArbitraryBufferSize);

            % Set the max AWG Buffer Size if the device has an AWG    
            obj.DriverData.awgBufferSize = pMaxArbitraryBufferSize.Value;

            obj.DriverData.minArbitraryWaveformValue = pMinArbitraryValue.Value;
            obj.DriverData.maxArbitraryWaveformValue = pMaxArbitraryValue.Value;

            % Set default
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;

            if (obj.DriverData.awgBufferSize &gt; 0)

                obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;

            else

                obj.DriverData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;

            end    

            % DAC frequency
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                            
            % Other device parameters

            obj.DriverData.autoTriggerMs = 0;
            obj.DriverData.autoTriggerUs = 0;
            obj.DriverData.delay = 0;

            % Set the default number of pre-trigger and post-trigger samples
            obj.DriverData.numPreTriggerSamples = 0;
            obj.DriverData.numPostTriggerSamples = 10000;

            % Set the timebase - 504 ns at 8-bit resolution
            obj.DriverData.timebase = 65;

            obj.DriverData.streamingInterval = 1e-6; % 1 us -&gt; 1MS/s
            obj.DriverData.autoStop = 1;

            obj.DriverData.startFrequency = 1000;
            obj.DriverData.stopFrequency = 1000;
            obj.DriverData.offsetVoltage = 0;
            obj.DriverData.peakToPeakVoltage = 2000;

            % Set whether to display output
            obj.DriverData.displayOutput = PicoConstants.TRUE;

            % Set device defaults for channels, ETS, trigger, block and
            % streaming mode data collection as well as signal generator.
            invoke(obj, 'resetDevice');

            % Find USB version
            infoLineUsb = blanks(15);
            reqSizeU = length(infoLineUsb);

            [connectStatus.usbVersion, usbVersion, ~]  = calllib('ps5000a', ...
                    'ps5000aGetUnitInfo', unitHandle, infoLineUsb, ... 
                    length(infoLineUsb), reqSizeU, PicoStatus.PICO_USB_VERSION);

            % Display unit information to user if not using TM Tool
            fprintf('\n');
            fprintf('Connected to PicoScope 5000 Series (A API) device:-\n\n');
            fprintf('          Instrument Model: %s\n', obj.InstrumentModel);
            fprintf('       Batch/Serial Number: %s\n', obj.DriverData.unitSerial);
            fprintf('               USB Version: %s\n', usbVersion);
            fprintf('           Analog Channels: %d\n', obj.DriverData.channelCount);

            if(obj.DriverData.digitalPortCount &gt; 0)

                fprintf('          Digital Channels: %d\n', obj.DriverData.digitalPortCount * 8);

            end

            fprintf('                Resolution: %d bits\n', obj.DriverData.resolution);

            % Bandwidth information
            bandwidthHz = obj.DriverData.bandwidth;

            if (bandwidthHz &gt; 0 &amp;&amp; bandwidthHz &lt; 1e9)

               fprintf('                 Bandwidth: %d MHz\n', (bandwidthHz/1e6));

            elseif(bandwithHz &gt;= 1e9)

               fprintf('                 Bandwidth: %d GHz\n', (bandwidthHz/1e9));

            else

                % Do nothing

            end

            fprintf('             Buffer Memory: %d MS\n', obj.DriverData.bufferMemory/pow2(20));

            % Sampling rate information
            maxSamplingRate = obj.DriverData.maxSamplingRate;

            if (maxSamplingRate &gt; 0 &amp;&amp; maxSamplingRate &lt; 1e9)

                fprintf('     Maximum Sampling Rate: %d MS/s\n', maxSamplingRate/1e6);

            elseif (maxSamplingRate &gt;= 1e9)

                fprintf('     Maximum Sampling Rate: %d GS/s\n', maxSamplingRate/1e9);

            else

                % Do nothing

            end

            clear bandwidthHz;
            clear maxSamplingRate;

            % Output the signal generator type
            sigGenType = 'None';

            switch (obj.DriverData.sigGenType)

                case PicoConstants.SIG_GEN_FUNCT_GEN

                    sigGenType = 'Function Generator';

                case PicoConstants.SIG_GEN_AWG

                    sigGenType = 'Arbitrary Waveform Generator';

                otherwise

                    % Already set to none

            end

            fprintf('     Signal Generator Type: %s\n', sigGenType);

            % Output if power supply connected.
            if (obj.DriverData.channelCount == PicoConstants.QUAD_SCOPE)

                currentPowerStatus = calllib('ps5000a', 'ps5000aCurrentPowerSource', unitHandle);

                if (currentPowerStatus == PicoStatus.PICO_POWER_SUPPLY_CONNECTED)

                    fprintf('5 V Power Supply connected: True\n');

                else

                    fprintf('5 V Power Supply connected: False\n');

                end

            end

            fprintf('\n');

        end

    elseif (connectStatus.openUnit == PicoStatus.PICO_NOT_FOUND)

        error('PS5000AConnect:NoUnitFound', 'No unit found, please check connections.');

    else

        error('PS5000AConnect:ConnectionError', ['Status code: ', connectStatus.openUnit, ' Please refer to the PicoStatus.m file']);

    end</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

    if (isfield(obj.DriverData, 'unitHandle'))
    
        unitHandle = obj.DriverData.unitHandle;

        if (isempty(unitHandle)) 
            % If no unithandle, return without doing anything
            return;
        end

        if (~libisloaded('ps5000a') &amp;&amp; ~libisloaded('ps5000aWrap'))

            % If the drivers are no longer loaded, return without doing
            % anything
            return;

        end
        
        % Disconnect Code:

        disconnectStatus = calllib('ps5000a', 'ps5000aCloseUnit', unitHandle);

        if (disconnectStatus == PicoStatus.PICO_OK)

            fprintf(['Connection to PicoScope %s with serial number %s ' ...
                'closed successfully.\n'], obj.InstrumentModel, obj.DriverData.unitSerial);

        elseif (disconnectStatus == PicoStatus.PICO_INVALID_HANDLE)
            
            % No device with the handle, so should be disconnected.
            return;
            
        else

            if (isfield(obj.DriverData, 'unitSerial'))
                
                error('Disconnect:ConnectionNotClosed',['Connection to PicoScope %s with serial number %s ' ...
                    'not closed. Status code %d\n'], ...
                    obj.InstrumentModel, obj.DriverData.unitSerial, disconnectStatus);
                
            end

        end
        
        % Only unload libraries if there are no more connected
        % oscilloscopes
        
        % Find the first handle number for the platform
        firstHandle = 0;
        
        if (ispc())
            
            firstHandle = 16384; % Windows PC
            
        else 
           
            firstHandle = 1; % Mac OS X and Linux
            
        end
        
        % Test the connection to a range of handle values up to a maximum
        lastHandle = firstHandle + obj.DriverData.constants.PS5000A_MAX_UNITS - 1;
        
        % Create an array to store status values for ping tests.
        % On Windows PCs, the first handle is 16384 so this will need to be
        % accounted for.
        if (ispc())
            
            pingStatus = zeros(lastHandle, 1);
            
        else
            
            pingStatus = zeros(obj.DriverData.constants.PS5000A_MAX_UNITS, 1);
            
        end
        
        % Test the handle value ranges
        for h = firstHandle:lastHandle

            pingStatus(h, 1) = calllib('ps5000a', 'ps5000aPingUnit', h);
            
        end
        
        if (ispc())
                
            % Need to resize arrray as first handle is not 0
            pingStatus(1:firstHandle - 1) = [];
                
        end
        
        if (any(pingStatus == PicoStatus.PICO_OK))
         
          % Device still connected
          disp('Other PicoScope 5000 Series (A API) devices are still connected - libraries will not be unloaded.');
          
        else

            unloadlibrary('ps5000aWrap');
            unloadlibrary('ps5000a');

            if (~libisloaded('ps5000a') &amp;&amp; ~libisloaded('ps5000aWrap'))

                disp('Libraries unloaded successfully.');

            else

                error('Libraries not unloaded successfully.');

            end
            
        end
    
    else
        
        warning('Disconnect:NoDevicesFound', 'Disconnect: No devices found.');
        
    end</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>bandwidth</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.bandwidth;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>bandwidth represents the maximum bandwidth (3dB cut-off point) of the oscilloscope in hertz.</Description>
            </Property>
            <Property>
               <Name>bufferMemory</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.bufferMemory;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>33554432</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Defines the size of the memory buffer on the device (in samples).</Description>
            </Property>
            <Property>
               <Name>channelCount</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.channelCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of analog input channels on the device.</Description>
            </Property>
            <Property>
               <Name>channelSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.channelSettings;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Object</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>A matrix containing the channel settings for analogue channels.

This will consist of a 4 x 4 matrix.

The row number will correspond to the channel:

1 - Channel A
2 - Channel B
3 - Channel C
4 - Channel D

Each row will contain the following elements corresponding to:

enabled - set to 0 (off) or 1 (on).
dc - set DC/AC coupling. 
range - an enumeration representing the voltage range.
analogueOffset - the offset on the channel.

</Description>
            </Property>
            <Property>
               <Name>digitalPorts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.digitalPortCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of digital ports on the device (MSO Devices only).</Description>
            </Property>
            <Property>
               <Name>digitalPortSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.digitalPortSettings;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    </SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A structure containing the channel settings for digital ports (MSO devices only).</Description>
            </Property>
            <Property>
               <Name>displayOutput</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.displayOutput;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.displayOutput = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration value to select whether to display output from function calls in the MATLAB Command Window.

Set to 1 to display output, 0 to hide output.

Note: Output will still be sent to the Command Window when calling the icdevice, connect and disconnect functions. Warning and error messages will still continue to be displayed from function calls.</Description>
            </Property>
            <Property>
               <Name>firstRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.firstRange;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration value corresponding to the lowest voltage range supported by the device. For further information, please refer to the enPS5000ARange enumeration set.</Description>
            </Property>
            <Property>
               <Name>hasHardwareEts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.hasHardwareEts;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Indicates if the device has hardware-based Equivalent Time Sampling.</Description>
            </Property>
            <Property>
               <Name>lastRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.lastRange;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration corresponding to highest voltage range supported by device. For further information, please refer to the enPS5000ARange enumeration set.</Description>
            </Property>
            <Property>
               <Name>maxADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.maxADCValue;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>32512</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>maxSamplingRate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.maxSamplingRate;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum single shot sampling rate for the device (samples per second).</Description>
            </Property>
            <Property>
               <Name>minADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.minADCValue;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>-32512</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The minimum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>numPostTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.numPostTriggerSamples;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numPostTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to be taken after a trigger event.

If no trigger event has been set then this specifies the maximum number of samples to be taken. If a trigger
condition has been set, this specifies the number of samples to be taken after a trigger has fired, and the number of samples to be
collected is then: -

numPreTriggerSamples + numPostTriggerSamples

When used in Streaming mode, this is the maximum number of raw samples after a trigger event for each enabled channel.</Description>
            </Property>
            <Property>
               <Name>numPreTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.numPreTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numPreTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to return before the trigger event.

If no trigger has been set then this argument is ignored and numPostTriggerSamples specifies the maximum number of samples to collect.

When used in Streaming mode, this is the maximum number of raw samples before the trigger event for each enabled channel.
</Description>
            </Property>
            <Property>
               <Name>resolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.resolution;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>8.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The resolution of the device, in bits.</Description>
            </Property>
            <Property>
               <Name>timebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.timebase;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.timebase = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>65</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The timebase used for the scope when capturing data in Block and Rapid Block mode - please refer to the Programmer's Guide for the formulae to calculate the timebase index based on the interval.

The default value set is 65 corresponding to a sampling interval of 504 ns at 8-bit resolution.

</Description>
            </Property>
            <Property>
               <Name>unitHandle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.unitHandle;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The handle assigned by the underlying shared library for the device.</Description>
            </Property>
            <Property>
               <Name>unitSerial</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.unitSerial;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>The device batch/serial number.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>deviceReset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function deviceReset(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    % Show warning message
    warning('PS5000AInstrumentDriver:DeviceResetNotSupported', ...
        'devicereset is not supported by this Instrument Driver - please use the resetDevice function instead.');</MCode>
               </Code>
               <Description>The devicereset function is not supported by this Instrument Driver. Please use the resetDevice function instead.</Description>
            </Method>
            <Method>
               <Name>getUnitInfo</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, unitInfoValues] = getUnitInfo(obj)

    unitInfoDesc = {'Driver version: '; 'USB version: '; 'Hardware version: '; 'Variant: '; ...
        'Batch &amp; Serial: '; 'Cal. Date: '; 'Kernel version: '; 'Digital HW version: '; ...
        'Analogue HW version: '};

    infoLine = blanks(100);

    unitInfoValues = cell(9,1);

    reqSize = 15;

    status = zeros(9,1);

    % Loop through and put together information
    for n = 1:9

        [status(n,1), infoLine1, reqSize]  = calllib('ps5000a', ...
            'ps5000aGetUnitInfo', obj.DriverData.unitHandle, infoLine, ... 
            length(infoLine), reqSize,(n-1));
        
        if (status(n,1) ~= PicoStatus.PICO_OK)
           
            % TBD - Error handling 
        
        end

        unitInfoLine = strcat(unitInfoDesc(n), infoLine1);
        unitInfoValues(n) = cellstr(unitInfoLine);
        
    end</MCode>
               </Code>
               <Description>getUnitInfo(obj) retrieves information about the specified oscilloscope for the following types of information:

1. Driver version
2. USB version
3. Hardware version
4. Variant number
5. Batch &amp; Serial number
6. Calibration date
7. Kernel Version
8. Digital Hardware version
9. Analog Hardware version

Input parameters:

obj - the object representing the device.

Output parameters:

status - an array containing the status codes returned by the driver on each call to the underlying ps5000aGetUnitInfo function.
unitInfoValues - a set of text providing information on the device connected to.

For further information on the underlying ps5000aGetUnitInfo function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aChangePowerSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aChangePowerSource(obj, powerstate)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aChangePowerSource', ...
                obj.DriverData.unitHandle, powerstate);
            
    if (status == PicoStatus.PICO_OK)
            
        % Retrieve channel settings - channel x data field matrix
        channelSettings = obj.DriverData.channelSettings; 
        
        % Turn off channels C and D if USB powered
        if (powerstate == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED &amp;&amp; ... 
                obj.DriverData.channelCount == PicoConstants.QUAD_SCOPE)
            
            channelC = obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C;
            channelD = obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D;
            
            if channelSettings(3,1) == PicoConstants.TRUE;
                
                statusChC = invoke(obj, 'ps5000aSetChannel', channelC, PicoConstants.FALSE, ...
                                    channelSettings(3,2), ... % DC Coupling
                                    channelSettings(3,3), ... % Range
                                    channelSettings(3,4));    % Analogue Offset

                % If successful update channel settings
                if (statusChC == PicoStatus.PICO_OK)

                    channelSettings(3,1) = PicoConstants.FALSE;

                else

                    error('ps5000aChangePowerSource calling ps5000aSetChannel for channel C: status code %d, please refer to the PicoStatus.m file.\n', statusChC);

                end
                
            end
            
            if channelSettings(4,1) == PicoConstants.TRUE;
                
                statusChD = invoke(obj, 'ps5000aSetChannel', channelD, PicoConstants.FALSE, ...
                                    channelSettings(4,2), ... % DC Coupling
                                    channelSettings(4,3), ... % Range
                                    channelSettings(4,4));    % Analogue Offset
            
                % If successful update channel settings
                if (statusChD == PicoStatus.PICO_OK)

                    channelSettings(4,1) = PicoConstants.FALSE;

                    else

                    error('ps5000aChangePowerSource calling ps5000aSetChannel for channel D: status code %d, please refer to the PicoStatus.m file.\n', statusChD);

                end
            
            end
                
            obj.DriverData.channelSettings = channelSettings;
            
            % Information to be passed to the wrapper dll
            enabledChannels = zeros(PicoConstants.QUAD_SCOPE, 1);
            
            % Pass information to wrapper dll
            enabledChannels = [channelSettings(1,1); ...
                                channelSettings(2,1); ...
                                channelSettings(3,1); ...
                                channelSettings(4,1)];
            
            setEnabledChannelsStatus = calllib('ps5000aWrap', 'setEnabledChannels', obj.DriverData.unitHandle, enabledChannels);
                    
        end
        
    else
        
        error('ps5000aChangePowerSource: status code %d, please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aChangePowerSource(obj, powerstate) is called to select the power supply mode.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
powerstate - the required state of the unit. Either PicoStatus.PICO_POWER_SUPPLY_CONNECTED,  PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED or PicoStatus.PICO_USB3_0_DEVICE_NON_USB3_0_PORT

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aChangePowerSource function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aCurrentPowerSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aCurrentPowerSource(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aCurrentPowerSource', obj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>ps5000aCurrentPowerSource(obj) returns the current power state of the device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - the current power state of the device or the status code for an invalid handle.</Description>
            </Method>
            <Method>
               <Name>ps5000aFlashLed</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aFlashLed(obj, start)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aFlashLed', obj.DriverData.unitHandle, start);
            
	if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aFlashLed: status code %d, please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aFlashLed(obj, start) flashes the LED on the front of the scope without blocking the calling thread.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
start - the action required:

	&lt; 0 : flash the LED indefinitely.
	0 : stop the LED flashing.
	&gt; 0 : flash the LED start times.

Output parameters:

status - status code returned by the device.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetAnalogueOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maximumVoltage, minimumVoltage] = ps5000aGetAnalogueOffset(obj, range, coupling)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Initialise pointers
    pMaxVoltage = libpointer('singlePtr', 0.0);    
    pMinVoltage = libpointer('singlePtr', 0.0);

    [status, ~, ~] = calllib('ps5000a', ...
        'ps5000aGetAnalogueOffset', obj.DriverData.unitHandle, range, coupling, ...
            pMaxVoltage, pMinVoltage);
    
    if (status ~= PicoStatus.PICO_OK)
       
        error('ps5000aGetAnalogueOffset: status code %d, please refer to the PicoStatus.m file.\n', status);
    
    end
    
    maximumVoltage = pMaxVoltage.Value;
    minimumVoltage = pMinVoltage.Value;</MCode>
               </Code>
               <Description>ps5000aGetAnalogueOffset(obj, range, coupling) is used to get the maximum and minimum allowable analogue offset for a specific voltage range.

This function may be used with the Test and Measurement Tool.

Input parameters: 

obj - the object representing the device.
range - an enPS5000ARange enumeration value representing the voltage range to be used.
coupling - an enPS5000ACoupling enumeration value representing the the type of AC/DC coupling used.

Output parameters:

status - status code returned by the driver.
maximumVoltage - the maximum voltage allowed for the range.
minimumVoltage - the minimum voltage allowed for the range.


</Description>
            </Method>
            <Method>
               <Name>ps5000aGetChannelInformation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ranges, length] = ps5000aGetChannelInformation(obj, channels)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Current info supported is PS5000A_CI_RANGES
    info = obj.DriverData.enums.enPS5000AChannelInfo.PS5000A_CI_RANGES;
    probe = 0;
    pRanges = libpointer('int32Ptr', zeros(10, 1, 'int32'));
    pLength = libpointer('int32Ptr', 10);

    [status, ~, ~] = calllib('ps5000a', ...
        'ps5000aGetChannelInformation', obj.DriverData.unitHandle, info, ...
        0, pRanges, pLength, channels);
    
    if (status ~= PicoStatus.PICO_OK)
           
       error('ps5000aGetChannelInformation: status code %d, please refer to the PicoStatus.m file.\n', status);
       
    end  
    
    ranges = pRanges.Value;
    length = pLength.Value;</MCode>
               </Code>
               <Description>ps5000aGetChannelInformation(obj, channels) queries which ranges are available on a scope device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channels - the channel for which the range information is required.

Output parameters:

status - status code returned by the driver.
ranges - an array that will be populated with available enPS5000A_RANGE enumeration values.
length - the number of elements written to the ranges array.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetDeviceResolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, resolution] = ps5000aGetDeviceResolution(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    pResolution = libpointer('enPS5000ADeviceResolution', obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_8BIT);
    resolution = 8;

    
    status = calllib('ps5000a', 'ps5000aGetDeviceResolution', ...
        obj.DriverData.unitHandle, pResolution);
    
    if (status == PicoStatus.PICO_OK)
            
        % Convert to value
    
        switch (deviceRes)
            
            case obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_8BIT
                
                resolution = 8;
                
            case obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_12BIT
                
                resolution = 12;
                
            case obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_14BIT
                
                resolution = 14;
                
            case obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_15BIT
                
                resolution = 15;
               
            case obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_16BIT
                
                resolution = 16;
                
            otherwise
                
                % Do nothing - PICO OK should indicate that the resolution
                % has returned successfully.
        end
        
        obj.DriverData.resolution = resolution;
        
        % TBD - Update the bandwidth and memory of the device.

    else
        
        error('ps5000aGetDeviceResolution: status code %d, please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aGetDeviceResolution(obj) retrieves the resolution (in bits) that the specified device will run in.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
resolution - the resolution (in bits) that the device will run in. 

The resolution property is also updated.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetMaxDownSampleRatio</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxDownSampleRatio] = ps5000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Value to which the max downsample ration is assigned
    pMaxDownSampleRatio = libpointer('uint32Ptr', 0);        

    [status] = calllib('ps5000a', 'ps5000aGetMaxDownSampleRatio', ...
        obj.DriverData.unitHandle, numUnaggregatedSamples, ...
            pMaxDownSampleRatio, downSampleRatioMode, segmentIndex);
        
    if (status ~= PicoStatus.PICO_OK)
           
      error('ps5000aGetMaxDownSampleRatio: status code %d, please refer to the PicoStatus.m file.\n', status);
        
    else
        
        maxDownSampleRatio = pMaxDownSampleRatio.Value;
      
    end   </MCode>
               </Code>
               <Description>ps5000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex) returns the maximum downsampling ratio that can be used for a given number of samples in a given downsampling mode.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
numUnaggregatedSamples - the number of unprocessed samples to be downsampled.
downSampleRatioMode - the downsampling mode.
segmentIndex - the memory segment where the data is stored.

Output parameters:

status - status code returned by the driver.
maxDownSampleRatio - the maximum possible downsampling ratio output.
</Description>
            </Method>
            <Method>
               <Name>ps5000aGetMaxSegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxSegments] = ps5000aGetMaxSegments(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Passing pointer to function
    pMaxSegments = libpointer('uint32Ptr', 0); 

    status = calllib('ps5000a', 'ps5000aGetMaxSegments', ...
                                obj.DriverData.unitHandle, pMaxSegments);
                            
	if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetMaxSegments: status code %d, please refer to the PicoStatus.m file.\n', status);
        
    end
    
    maxSegments = pMaxSegments.Value;</MCode>
               </Code>
               <Description>ps5000aGetMaxSegments(obj) returns the maximum number of segments allowed for the opened device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the device.
maxSegments - the maximum number of segments allowed.
</Description>
            </Method>
            <Method>
               <Name>ps5000aGetTimebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIntervalNanoSeconds, maxSamples] = ps5000aGetTimebase(obj, timebase, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    pTimeIntervalNanoSeconds = libpointer('int32Ptr', 0);
    numSamples = obj.DriverData.numPreTriggerSamples + obj.DriverData.numPostTriggerSamples;
    pMaxSamples = libpointer('int32Ptr', 0); % Pass data to return the max samples from the driver
    
    [status, timeIntervalNanoSeconds, maxSamples] = calllib('ps5000a', ...
        'ps5000aGetTimebase', obj.DriverData.unitHandle, timebase, numSamples, ...
        pTimeIntervalNanoSeconds, pMaxSamples, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        % Inform the User that an invalid timebase index has been selected
        if (status == PicoStatus.PICO_INVALID_TIMEBASE)
           
            warning('PS5000AInstrumentDriver:InvalidTimebase', ['Invalid timebase ', ...
                'index used in call to ps5000aGetTimebase().']);
            
        else
            
            error('PS5000AInstrumentDriver:PS5000aGetTimebase', ['ps5000aGetTimebase2:- Status code: ', ...
                '%d. Please refer to the PicoStatus.m file.'], status);
        
        end
    
    else
        
        timeIntervalNanoSeconds = pTimeIntervalNanoSeconds.Value;
        maxSamples = pMaxSamples.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetTimebase(obj, timebase, segmentIndex) calculates the sampling rate and maximum number of samples for a given timebase under the specified conditions.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
timebase: a timebase index.
segmentIndex: the index of the memory segment to use.

Output parameters:

status - status code returned by the driver.
timeIntervalNanoSeconds: the time interval between readings at the selected timebase.
maxSamples: the maximum number of samples available. </Description>
            </Method>
            <Method>
               <Name>ps5000aGetTimebase2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIntervalNanoSeconds, maxSamples] = ps5000aGetTimebase2(obj, timebase, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    pTimeIntervalNanoSeconds = libpointer('singlePtr', 0);
    numSamples = obj.DriverData.numPreTriggerSamples + obj.DriverData.numPostTriggerSamples;
    pMaxSamples = libpointer('int32Ptr', 0); % Pass data to return the max samples from the driver
    
    [status, timeIntervalNanoSeconds, maxSamples] = calllib('ps5000a', ...
        'ps5000aGetTimebase2', obj.DriverData.unitHandle, timebase, numSamples, ...
        pTimeIntervalNanoSeconds, pMaxSamples, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        % Inform the User that an invalid timebase index has been selected
        if (status == PicoStatus.PICO_INVALID_TIMEBASE)
           
            warning('PS5000AInstrumentDriver:InvalidTimebase', ['Invalid timebase ', ...
                'index used in call to ps5000aGetTimebase2().']);
            
        else
            
            error('PS5000AInstrumentDriver:PS5000aGetTimebase', ['ps5000aGetTimebase2:- Status code: ', ...
                '%d. Please refer to the PicoStatus.m file.'], status);
        
        end
    
    else
        
        timeIntervalNanoSeconds = pTimeIntervalNanoSeconds.Value;
        maxSamples = pMaxSamples.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetTimebase2(obj, timebase, segmentIndex) is an upgraded version of ps5000aGetTimebase, and returns the time interval as a float rather than a long integer. This allows it to return sub-nanosecond time intervals.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
timebase: a timebase index.
segmentIndex: the index of the memory segment to use.

Output parameters:

status - status code returned by the driver.
timeIntervalNanoSeconds: the time interval between readings at the selected timebase.
maxSamples: the maximum number of samples available. </Description>
            </Method>
            <Method>
               <Name>ps5000aMaximumValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aMaximumValue(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Show warning message
    warning('PS5000AInstrumentDriver:FunctionDeprecated', ...
        'ps5000aMaximumValue is not supported by this Instrument Driver - please use the maxADCValue property instead.');</MCode>
               </Code>
               <Description>ps5000aMaximumValue(obj) has been deprecated. Please query the base device maxADCValue function instead.
</Description>
            </Method>
            <Method>
               <Name>ps5000aMemorySegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nMaxSamples] = ps5000aMemorySegments(obj, nSegments)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    pNMaxSamples = libpointer('int32Ptr', 0); % Initialise value for pointer

    status = calllib('ps5000a', 'ps5000aMemorySegments', ...
                obj.DriverData.unitHandle, nSegments, pNMaxSamples);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aMemorySegments: status code %d, please refer to the PicoStatus.m file.\n', status);
        
    else
        
        nMaxSamples = pNMaxSamples.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aMemorySegments(obj, nSegments) sets the number of memory segments that the scope will use.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
nSegments - the number of segments required (see ps5000aGetMaxSegments).

Output parameters:

status - status code returned by the driver.
nMaxSamples - the number of samples available in each segment. This is the total number over
all channels, so if two channels or 8-bit digital ports are in use, the number of samples available to each
channel is nMaxSamples divided by 2; for 3 or 4 channels or digital ports divide by 4; and for 5 to 6 channels
or digital ports divide by 8.</Description>
            </Method>
            <Method>
               <Name>ps5000aMinimumValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aMinimumValue(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Show warning message
    warning('PS5000AInstrumentDriver:FunctionDeprecated', ...
        'ps5000aMinimumValue is not supported by this Instrument Driver - please use the minADCValue property instead.');</MCode>
               </Code>
               <Description>ps5000aMinimumValue(obj) has been deprecated. Please query the base device minADCValue function instead.
</Description>
            </Method>
            <Method>
               <Name>ps5000aPingUnit</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aPingUnit(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aPingUnit', obj.DriverData.unitHandle);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aPingUnit: status code %d, please refer to the PicoStatus.m file.', status);
        
    end </MCode>
               </Code>
               <Description>ps5000aPingUnit(obj) can be used to check that the already opened device is still connected to the USB port and communication is successful.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetBandwidthFilter</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetBandwidthFilter(obj, channel, bandwidth)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    channelCount = obj.DriverData.channelCount;
    
    if (channelCount == PicoConstants.QUAD_SCOPE)
        
            currentPowerState = calllib('ps5000a', 'ps5000aCurrentPowerSource', obj.DriverData.unitHandle);
        
            if (currentPowerState == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
           
                channelCount = PicoConstants.DUAL_SCOPE;
                
            end
            
    end
    
    if (channelCount == PicoConstants.DUAL_SCOPE)
        
        if (channel &lt; obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A ...
            || channel &gt; obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B)

            error('ps5000aSetBandwidthFilter: Invalid channel number (should be 0 (A) to 1 (B)');    

        end
        
        
    elseif (channelCount == PicoConstants.QUAD_SCOPE)
        
        if (channel &lt; obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A ...
            || channel &gt;= obj.DriverData.enums.enPS5000AChannel.PS5000A_MAX_CHANNELS)

            error('ps5000aSetBandwidthFilter: Invalid channel number (should be 0 (A) to 3 (D)');    

        end
        
    else
        
        % Do nothing
        
    end

    if (bandwidth ~= obj.DriverData.enums.enPS5000ABandwidthLimiter.PS5000A_BW_FULL ...
        &amp;&amp; bandwidth ~= obj.DriverData.enums.enPS5000ABandwidthLimiter.PS5000A_BW_20MHZ)

        error('ps5000aSetBandwidthFilter: bandwidth must be 0 (Full) or 1 (20MHz).')

    end

    status = calllib('ps5000a', 'ps5000aSetBandwidthFilter', obj.DriverData.unitHandle, channel, bandwidth);

    if (status ~= PicoStatus.PICO_OK)

        error('ps5000aSetBandwidthFilter: status code %d, please refer to the PicoStatus.m file.', status);

    end   </MCode>
               </Code>
               <Description>ps5000aSetBandwidthFilter(obj, channel, bandwidth) specifies the bandwidth limit.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the enPS5000AChannel range).
bandwidth - the bandwidth is either enPS5000ABandwidthLimiter.PS5000A_BW_FULL (0) or enPS5000ABandwidthLimiter.PS5000A_BW_20MHZ (1).

Output parameters:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetChannel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetChannel(obj, channel, enabled, type, range, analogueOffset)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aSetChannel', obj.DriverData.unitHandle, ...
                channel, enabled, type, range, analogueOffset);
    
    % Convert cell array to channel x data field matrix
    channelSettings = obj.DriverData.channelSettings;
            
	if (status == PicoStatus.PICO_OK)
        
        switch (channel)
            
            case obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A
                
                channelSettings(1,1) = enabled;
                channelSettings(1,2) = type;
                channelSettings(1,3) = range;
                channelSettings(1,4) = analogueOffset; 
                
            case obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B
                
                channelSettings(2,1) = enabled;
                channelSettings(2,2) = type;
                channelSettings(2,3) = range;
                channelSettings(2,4) = analogueOffset; 

            case obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C
                
                channelSettings(3,1) = enabled;
                channelSettings(3,2) = type;
                channelSettings(3,3) = range;
                channelSettings(3,4) = analogueOffset;  
                
            case obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D
                
                channelSettings(4,1) = enabled;
                channelSettings(4,2) = type;
                channelSettings(4,3) = range;
                channelSettings(4,4) = analogueOffset; 
                
            otherwise
                
                % Do nothing
                    
        end
        
        obj.DriverData.channelSettings = channelSettings;
        
        % Information to be passed to the wrapper dll
        enabledChannels = zeros(PicoConstants.QUAD_SCOPE, 1);
        
        switch (obj.DriverData.channelCount)
            
            case PicoConstants.DUAL_SCOPE
           
                % Only channels A and B
                enabledChannels = [channelSettings(1,1); ...
                                    channelSettings(2,1); 0; 0];
            
            case PicoConstants.QUAD_SCOPE
                
                enabledChannels = [channelSettings(1,1); ...
                                    channelSettings(2,1); ...
                                    channelSettings(3,1); ...
                                    channelSettings(4,1)];
            
            otherwise
        
                % Do nothing
            
        end
        
        setEnabledChannelsStatus = calllib('ps5000aWrap', 'setEnabledChannels', obj.DriverData.unitHandle, enabledChannels);
        
    else
        
        error('ps5000aSetChannel: status code %d, please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetChannel(obj, channel, enabled, type, range, analogueOffset) specifies whether an input channel is to be enabled, its input coupling type, voltage range, analog offset and bandwidth limit.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the enPS5000AChannel range).
enabled - set to TRUE (1) to enable the channel, FALSE (0) otherwise.
type - the impedance and coupling type (an enumeration from the enPS5000ACoupling range).
range - the input voltage range (an enumeration from the enPS5000ARange set).
analogueOffset - a voltage to add to the input channel before digitization.

Output parameters:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDataBuffer</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetDataBuffer(obj, channel, buffer, bufferLth, segmentIndex, mode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aSetDataBuffer', obj.DriverData.unitHandle, ...
                channel, buffer, bufferLth, segmentIndex, mode);
            
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetDataBuffer: status code %d, please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDataBuffer(obj, channel, buffer, bufferLth, segmentIndex, mode) tells the driver where to store the data, either unprocessed or downsampled, that will be returned after the next call to one of the GetValues functions.

Input parameters:

obj - the object representing the device.
channel - the channel to which the buffer corresponds (an enumeration from the enPS5000AChannel range).
buffer - a libpointer to a 1-D array to receive the data values for the channel.
bufferLth - the length of the buffer array.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode (an enumeration from the enPS5000ARatioMode range).

Output parameters:

status - status code returned by the device.

If capturing data in streaming mode without aggregation, buffer must also be passed as the driverBuffer argument for the setAppAndDriverBuffers function call.

</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDataBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aSetDataBuffers', ...
        obj.DriverData.unitHandle, channel, pBufferMax, pBufferMin, bufferLth, ...
        segmentIndex, ratioMode);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetDataBuffers: status code %d, please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode) tells the driver the location of one or two buffers for receiving data.

If aggregate mode is not being used, then ps5000aSetDataBuffer can optionally be used instead.

Input parameters:

obj - the object representing the device.
channel -  the channel for which to set the buffers (an enumeration from the PS5000A_CHANNEL range).
pBufferMax - a libpointer to a 1-D array to receive the maximum data values in aggregation mode, or the non-aggregated values otherwise.
pBufferMin -  a libpointer to a 1-D array to receive the minimum aggregated data values. Not used in other downsampling modes.
bufferLth - the size of the arrays to which pBufferMax and pBufferMin are pointers.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode to use (an enumeration from the PS5000A_RATIO_MODE range).

Output parameters:

status - status code returned by the device.

If capturing data in streaming mode with aggregation, pBufferMax and pBufferMin must also be passed as the driverMaxBuffer and driverMinBuffer arguments respectively for the setMaxMinAppAndDriverBuffers function call.

For further information on the ps5000aSetDataBuffers function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDeviceResolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, resolution] = ps5000aSetDeviceResolution(obj, resolution)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Initialise a value for the resolution.
    deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_8BIT;
    
    % Verify resolution is valid
    
    % Find number of active channels
    
    % Obtain channel settings
    channelSettings = obj.DriverData.channelSettings;

    % Array to represent channels enabled
    enabledChannels = zeros(PicoConstants.QUAD_SCOPE, 1);
    
    switch (obj.DriverData.channelCount)
            
        case PicoConstants.DUAL_SCOPE

            % Only channels A and B
            enabledChannels = [channelSettings(1,1); ...
                                channelSettings(2,1); 0; 0];

        case PicoConstants.QUAD_SCOPE

            enabledChannels = [channelSettings(1,1); ...
                                channelSettings(2,1); ...
                                channelSettings(3,1); ...
                                channelSettings(4,1)];

        otherwise

            % Do nothing
            
    end
    
    numChannelsEnabled = length(find(enabledChannels));
    
    switch(resolution)
        
        case 8
            
            % No change to device_res
            
        case 12
            
            deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_12BIT;
            
        case 14
            
            deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_14BIT;
            
        case 15
            
            deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_15BIT;
            
            if (numChannelsEnabled &gt; 2)
                
                deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_14BIT;
                resolution = 14;
            end
            
        case 16

            deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_16BIT;
            
            if (numChannelsEnabled == 2)
               
                deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_15BIT;
                resolution = 15;
                
            elseif (numChannelsEnabled &gt; 2)
                
                deviceRes = obj.DriverData.enums.enPS5000ADeviceResolution.PS5000A_DR_14BIT;
                resolution = 14;
                
            else
                
                % Leave as 16-bit
                
            end
            
        otherwise
        
            error('ps5000aSetDeviceResolution: Resolution must be 8, 12, 14, 15 or 16 bits.');
            
    end

    status = calllib('ps5000a', 'ps5000aSetDeviceResolution', obj.DriverData.unitHandle, deviceRes);
    
    if (status == PicoStatus.PICO_OK)
           
        % Set local resolution value
        obj.DriverData.resolution = resolution;
        
        if (obj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('ps5000aSetDeviceResolution: Device resolution set to %d bits.\n\n', resolution);
            
        end
        
        % Set the maximum and minimum ADC count value
        
        % Set the max. ADC value
        maxValPtr = libpointer('int16Ptr', 0);
        
        [maxValueStatus, ~]  = calllib('ps5000a', 'ps5000aMaximumValue', obj.DriverData.unitHandle, maxValPtr);

        obj.DriverData.maxADCValue = maxValPtr.Value;
        
        % Set the min. ADC value 
        minValPtr = libpointer('int16Ptr', 0);

        [minValueStatus, ~] = calllib('ps5000a', 'ps5000aMinimumValue', obj.DriverData.unitHandle, minValPtr);

        obj.DriverData.minADCValue = minValPtr.Value;
        
        % Depending on resolution set:
        %   Bandwidth
        %   Buffer memory - TBD next release
        
        if (resolution &lt; 16)
           
            modelVariant = obj.InstrumentModel;
                
                if(strncmp(modelVariant, '5242', 4) || strncmp(modelVariant, '5442', 4))
                    
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
                    
                elseif(strncmp(modelVariant, '5243', 4) || strncmp(modelVariant, '5443', 4))
                    
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                    
                elseif(strncmp(modelVariant, '5244', 4) || strncmp(modelVariant, '5444', 4))
                    
                    obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                        
                else
                    
                    % Do nothing
                
                end
                
        else
            
            obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
            
        end
            
        % If valid, and 12-bits or greater, halve the memory and update the bandwidth if required
        if (resolution &gt;= 12)
            
            % Select the correct first range
            % TODO - Buffer memory
            
        else
            
            % Set defaults for 8-bit resolution
            
        end
           
    else
        
        error('ps5000aSetDeviceResolution: Device resolution not set.');
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDeviceResolution(obj, resolution) sets the new resolution. 

When using 12 bits or more the memory is halved. When using 15-bit resolution only 2 channels can be enabled to capture data, and when using 16-bit resolution only one channel is available.

The maximum resolution possible for the number of channels enabled will be set if the selected resolution cannot be used with 
the number of channels selected.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
resolution - the desired resolution in bits (8, 12, 14, 15 or 16).

Output parameters:

status - status code returned by the driver.
resolution - the resolution set by the driver.
</Description>
            </Method>
            <Method>
               <Name>ps5000aStop</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aStop(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000a', 'ps5000aStop', obj.DriverData.unitHandle);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aStop: status code %d, please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aStop(obj) stops the scope device from sampling data.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>resetDevice</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function resetDevice(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Reset Channels
    [chA, chB, chC, chD] = invoke(obj, 'setChannelDefaults');
    
    % Digital ports
    
    % Obtain Digital group object
    digitalGroupObj = get(obj, 'Digital');
    digitalGroupObj = digitalGroupObj(1);

    % Set digital port defaults if device has digital channels   
    if (obj.DriverData.digitalPortCount &gt; 0)

        setDigitalPortStatus = invoke(digitalGroupObj, 'setDigitalPortDefaults');

    end
    
    % Obtain Digital group object
    blockGroupObj = get(obj, 'Block');
    blockGroupObj = blockGroupObj(1);
    
    % Turn off ETS

    disp('Turning off Equivalent Time Sampling...');
    
    [etsStatus, stPs] = invoke(blockGroupObj, 'ps5000aSetEts', obj.DriverData.enums.enPS5000AEtsMode.PS5000A_ETS_OFF, 0, 0);
    
    fprintf('Equivalent Time Sampling turned off.\n\n');
    
    % Turn off trigger

    % Obtain Digital group object
    triggerGroupObj = get(obj, 'Trigger');
    triggerGroupObj = triggerGroupObj(1);
    
    obj.DriverData.autoTriggerMs = 0;
    obj.DriverData.autoTriggerUs = 0;
    obj.DriverData.delay = 0;
    
    fprintf('Turning off trigger...\n');
    
    triggerStatus = invoke(triggerGroupObj, 'setTriggerOff');

    fprintf('Trigger turned off.\n\n');
    
    fprintf('Default Block mode parameters:-\n\n');
    
    % Set the default number of pre-trigger and post-trigger samples
    obj.DriverData.numPreTriggerSamples = 0;
    obj.DriverData.numPostTriggerSamples = 10000;
    
    totalSamples = obj.DriverData.numPreTriggerSamples + obj.DriverData.numPostTriggerSamples;
    
    % Timebase
    obj.DriverData.timebase = 65;
    timeIntervalNs = 0;
    segmentIndex = 0;
    
    % Call get timebase to return interval in ns 
    
    [timebaseStatus, intervalNs, maxBlockSamples] = invoke(obj, 'ps5000aGetTimebase2', obj.DriverData.timebase, segmentIndex);
    
    fprintf('               Timebase index : %d\n', obj.DriverData.timebase);
    fprintf('                 Time Interval: %u ns\n', intervalNs);
    fprintf(' Number of pre-trigger samples: %d\n', obj.DriverData.numPreTriggerSamples);
    fprintf('Number of post-trigger samples: %d\n', obj.DriverData.numPostTriggerSamples);
    fprintf('       Total number of samples: %d\n', totalSamples);
    
    fprintf('\n');
    
    fprintf('Default Streaming mode parameters:-\n\n');
    
    obj.DriverData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
    obj.DriverData.autoStop = PicoConstants.TRUE;
    
    fprintf(' Streaming interval: %1.2d s\n', obj.DriverData.streamingInterval);
    fprintf('Streaming auto stop: %d\n', obj.DriverData.autoStop);
    
    fprintf('\n');
    
    if (obj.DriverData.sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN || ...
            obj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)
       
        fprintf('Default Signal generator parameters:-\n\n');
        
        obj.DriverData.startFrequency = 1000;
        obj.DriverData.stopFrequency = 1000;
        obj.DriverData.offsetVoltage = 0;
        obj.DriverData.peakToPeakVoltage = 2000;
        
     	fprintf('Start frequency: %d Hz\n', obj.DriverData.startFrequency);
        fprintf(' Stop frequency: %d Hz\n', obj.DriverData.stopFrequency);
        
    end</MCode>
               </Code>
               <Description>resetDevice(obj) sets the default parameters for the device.

This includes the folliowing:

1. Device specific properties.
2. Enabling all available channels to 5V range, DC coupled with 0 analogue offset.
3. Turning off the trigger and ETS mode.
4. Block mode parameters:

	Timebase index - 65, corresponding to a sampling interval of 504ns or ~1us depending on the device.
	numPreTriggerSamples - 0
 	numPostTriggerSamples - 1024

5. Streaming mode parameters:

	streamingInterval - 1e-6 (seconds)
	autoStop - 1
    
6. Signal Generator parameters:
        
	startFrequency = 1000 (Hz)
	stopFrequency = 1000 (Hz)

</Description>
            </Method>
            <Method>
               <Name>setChannelDefaults</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [setChA, setChB, setChC, setChD] = setChannelDefaults(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    fprintf('Default Channel Setup:-\n');
    fprintf('-----------------------\n\n');

    chA = obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A;
    chB = obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B;

    % Assign values used repeatedly to local variable

    true = PicoConstants.TRUE;
    range5V = obj.DriverData.enums.enPS5000ARange.PS5000A_5V;
    analogueOffset = 0;

    % Set default values for output in case channels are not available on 
    % the device.
    setChC = [];
    setChD = [];
    setD0 = [];
    setD1 = [];
    
    % Matrix of values to represent channels (rows) x properties (cols)
    channelSettings = zeros(PicoConstants.QUAD_SCOPE);
    
    % Set Channel A and B, updating internal settings
    % Parameters are channel index, enabled, dc coupling, range index and 
    % analogue offset

    % Update internal setting
    channelSettings(1,1) = true;
    channelSettings(1,2) = true;
    channelSettings(1,3) = range5V;
    channelSettings(1,4) = analogueOffset; 
    
    channelSettings(2,1) = true;
    channelSettings(2,2) = true;
    channelSettings(2,3) = range5V;
    channelSettings(2,4) = analogueOffset; 
    
    obj.DriverData.channelSettings = channelSettings;
    
    setChA = invoke(obj, 'ps5000aSetChannel', chA, true, true, range5V, analogueOffset);
    fprintf('Channel A:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5 V\n\tAnalog offset: 0.0 V\n\n');

    setChB = invoke(obj, 'ps5000aSetChannel', chB, true, true, range5V, analogueOffset);
    fprintf('Channel B:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5 V\n\tAnalog offset: 0.0 V\n\n');
    
    % If device is a 544XA/B/D/D MSO enable channels C and D
    % Check power status
    powerStatus = invoke(obj, 'ps5000aCurrentPowerSource');
    
    if (obj.DriverData.channelCount == PicoConstants.QUAD_SCOPE &amp;&amp; ...
            powerStatus == PicoStatus.PICO_POWER_SUPPLY_CONNECTED)
    
        chC = obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C;
        chD = obj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D;
        
        % Update internal setting
        channelSettings(3,1) = true;
        channelSettings(3,2) = true;
        channelSettings(3,3) = range5V;
        channelSettings(3,4) = analogueOffset; 

        channelSettings(4,1) = true;
        channelSettings(4,2) = true;
        channelSettings(4,3) = range5V;
        channelSettings(4,4) = analogueOffset; 
    
        obj.DriverData.channelSettings = channelSettings;

        setChC = invoke(obj, 'ps5000aSetChannel', chC, true, true, range5V, analogueOffset);
        fprintf('Channel C:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5 V\n\tAnalog offset: 0.0 V\n\n');

        setChD = invoke(obj, 'ps5000aSetChannel', chD, true, true, range5V, analogueOffset);
        fprintf('Channel D:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5 V\n\tAnalog offset: 0.0 V\n\n');
        
        clear chC;
        clear chD;
        
    end
    
    % Clear local variables
    clear chA;
    clear chB;
    clear true;
        </MCode>
               </Code>
               <Description>setChannelDefaults(obj) sets the following default values for any analog channels found on the device:

Analogue channel:

Enabled: True
Coupling: DC
Voltage Range: 5V
Analog offset: 0 V

Input parameters:

obj - the object representing the device.

Output parameters:

chA - status for setting channel A
chB - status for setting channel A
chC - status for setting channel C (4 channel devices only)
chD - status for setting channel D (4 channel devices only)</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>block</Name>
         <Description>The Block group contains a set of properties and functions related to the block mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Block1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getBlockData</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, channelA, channelB, channelC, channelD, dPort0, dPort1] = getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS5000ARatioMode.PS5000A_RATIO_MODE_AGGREGATE)
        
        unitHandle = deviceObj.DriverData.unitHandle;
        
        channelCount = deviceObj.DriverData.channelCount;

        portCount = deviceObj.DriverData.digitalPortCount;

        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings;
        
        % Retrieve port settings - port x data field matrix
        portSettings = deviceObj.DriverData.digitalPortSettings;
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];
        
        dPort0 = [];
        dPort1 = [];

        % Overflow indicator
        overflow = 0;

        % Initialise variable for array of libpointers for analogue
        % channels
        pABuffer = libpointer;
        
        % Initialise status
        setBufferStatus = 0;

        % Total number of samples to set for data buffers, taking into
        % account the downsampling ratio
        totalSamples = ceil((deviceObj.DriverData.numPreTriggerSamples + ...
            deviceObj.DriverData.numPostTriggerSamples) / ratio);
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getBlockData: Setting up data buffers...\n');

        end
        
        % For 4-channel models verify power supply is connected
        % Only 2-channels are enabled if the power supply is not connected
        
        if (channelCount == PicoConstants.QUAD_SCOPE)
        
            currentPowerState = invoke(deviceObj, 'ps5000aCurrentPowerSource');
        
            if (currentPowerState == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
           
                channelCount = PicoConstants.DUAL_SCOPE;
                
            end
            
        end
        
        for ch = 1:channelCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (channelSettings(ch,1) == PicoConstants.TRUE)
                
                % Store array of libpointers
                pABuffer(ch) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps5000a', 'ps5000aSetDataBuffer', unitHandle, ...
                    (ch - 1), pABuffer(ch), totalSamples, segmentIndex, ratioMode);
                
                if (setBufferStatus ~= PicoStatus.PICO_OK)
                    
                    error('getBlockData: Set Data Buffer for Channel %d error code %d', ...
                        (ch - 1), setBufferStatus);
                    
                end

            end

        end

        % Initialise variable for array of libpointers for digital
        % channels
        pDBuffer = libpointer;

        for port = 1:portCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (portSettings(port,1) == PicoConstants.TRUE)

                % Store array of libpointers
                pDBuffer(port) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps5000a', 'ps5000aSetDataBuffer', ...
                    unitHandle, (port - 1 + deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0), ... 'PORT0 = 128, PORT1 = 129
                    pDBuffer(port), totalSamples, segmentIndex, ratioMode);

                if (setBufferStatus ~= PicoStatus.PICO_OK)

                    error('getBlockData:- Set Data Buffer for Digital Port %d status code: %d', ...
                        (port - 1), setBufferStatus);

                end

            end

        end
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getBlockData: Retrieving data...\n');
            
        end
        
        % Call ps5000aGetValues
        [getValuesStatus, numSamples, overflow] = calllib('ps5000a', 'ps5000aGetValues', unitHandle, ...
            startIndex, totalSamples, ratio, ratioMode, segmentIndex, overflow);
        
        if (getValuesStatus == PicoStatus.PICO_OK)
            
            if (portCount &gt; 0 &amp;&amp; deviceObj.DriverData.displayOutput == PicoConstants.TRUE)

                fprintf('getBlockData: Assigning digital data to port array.\n');

            end
            
            for port = 1:portCount

                if (portSettings(port,1) == PicoConstants.TRUE)

                    switch (port - 1 + deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0)

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0

                            dPort0 = pDBuffer(port).Value;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT1

                            dPort1 = pDBuffer(port).Value;

                        otherwise

                            % Do nothing

                    end

                end

            end
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
                fprintf('getBlockData: Assigning analog data to array and converting to millivolts.\n');
                
            end
            
            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);
            
            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)
                    
                    % Obtain the index for the
                    % PicoConstants.SCOPE_INPUT_RANGES array corresponding
                    % to the voltage range selected for the channel.
                    scopeInputIndex = channelSettings(ch,3) + 1;
                    voltageRange = PicoConstants.SCOPE_INPUT_RANGES(scopeInputIndex);
                    
                    bufferValues = adc2mv(pABuffer(ch).Value, voltageRange, maxADCValue);

                    switch(ch - 1)

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D

                            channelD = bufferValues;

                        otherwise

                            % Do nothing

                    end
                    
                end
                
            end
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
                fprintf('getBlockData: Data succesfully retrieved.\n');
                
            end
            
        else
            
            error('getBlockData:- status code: %d. Please refer to the PicoStatus.m file.', getValuesStatus);
            
        end
        
        
    else
        
        error('getBlockData: Aggregate Mode data collection not supported by this function.');
        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
        fprintf('\n');
        
    end</MCode>
               </Code>
               <Description>getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode) returns block mode data with or without downsampling starting at the specified sample number.

Memory for the data arrays is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode is NOT supported by this function.

Channels not enabled or not supported by the device (e.g. channels C and D for a 2-channel oscilloscope) will be returned as an empty array.

This function can be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection. Use zero to start at the first sample.
segmentIndex - the number of the memory segment to be used/where the data is stored. Use 0 if the memory has not been segmented.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by an enumeration from the enPS5000aRatioMode range of enumerations excluding PS5000A_RATIO_MODE_AGGREGATE).


Output Arguments:

status - status code returned by the driver.
numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
channelA - an array containing data values (in millivolts) for channel A.
channelB - an array containing data values (in millivolts) for channel B.
channelC - an array containing data values (in millivolts) for channel C.
channelD - an array containing data values (in millivolts) for channel D.
portD0 - an array containing data values in binary format for digital Port 0 (in MSB order)
portD1 - an array containing data values in binary format for digital Port 1 (in MSB order)

Please also refer to the ps5000aSetDataBuffer, and ps5000aGetValues functions.
</Description>
            </Method>
            <Method>
               <Name>getEtsBlockData</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, etsTimes, channelA, channelB, channelC, channelD] = getEtsBlockData(obj, startIndex, segmentIndex, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    unitHandle = deviceObj.DriverData.unitHandle;

    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS5000ARatioMode.PS5000A_RATIO_MODE_AGGREGATE)
        
        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings; 
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];

        % Overflow indicator
        overflow = 0;

        % Initialise variable for array of libpointers
        pBuffer = libpointer;
        
        % Initialise status
        setBufferStatus = 0;

        % Total number of samples to set for data buffers, taking into
        % account the downsampling ratio
        totalSamples = ceil((deviceObj.DriverData.numPreTriggerSamples + deviceObj.DriverData.numPostTriggerSamples) / ratio);
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getEtsBlockData: Setting up data buffers...\n');
            
        end

        channelCount = deviceObj.DriverData.channelCount;
        
        % For 4 channel models verify power supply is connected
        % Only 2 channels are enabled if the power supply is not connected
        
        if (channelCount == PicoConstants.QUAD_SCOPE)
        
            currentPowerState = invoke(deviceObj, 'ps5000aCurrentPowerSource');
        
            if (currentPowerState == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
           
                channelCount = PicoConstants.DUAL_SCOPE;
                
            end
            
        end

        for ch = 1:channelCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (channelSettings(ch,1) == PicoConstants.TRUE)
                
                % Store array of libpointers
                pBuffer(ch) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps5000a', 'ps5000aSetDataBuffer', unitHandle, ...
                    (ch - 1), pBuffer(ch), totalSamples, segmentIndex, ratioMode);
                
                if (setBufferStatus ~= PicoStatus.PICO_OK)
                    
                    error('getEtsBlockData: Set Data Buffer for Channel %d error code %d', ...
                        (ch - 1), setBufferStatus);
                    
                end

            end

        end
        
        % Set ETS Time buffer
        pEtsTimeBuffer = libpointer('int64Ptr', zeros(totalSamples, 1, 'int64'));

        status = calllib('ps5000a', 'ps5000aSetEtsTimeBuffer', ...
                    unitHandle, pEtsTimeBuffer, totalSamples);
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
            fprintf('getEtsBlockData: Retrieving data...\n');
            
        end

        % Call ps5000aGetValues
        [getValuesStatus, numSamples, overflow] = calllib('ps5000a', 'ps5000aGetValues', ...
            unitHandle, startIndex, totalSamples, ratio, ratioMode, ...
            segmentIndex, overflow);

        if (getValuesStatus == PicoStatus.PICO_OK)
            
            % Retrieve ETS times
            etsTimes = pEtsTimeBuffer.Value;  
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getEtsBlockData: Assigning data to array and converting to millivolts.\n');
                
            end
            
            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);
            
            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)
                    
                    % Obtain the index for the
                    % PicoConstants.SCOPE_INPUT_RANGES array corresponding
                    % to the voltage range selected for the channel.
                    scopeInputIndex = channelSettings(ch,3) + 1;
                    voltageRange = PicoConstants.SCOPE_INPUT_RANGES(scopeInputIndex);
                    
                    % Obtain the voltage range for the channel.
                    bufferValues = adc2mv(pBuffer(ch).Value, voltageRange, maxADCValue);

                    switch(ch - 1)

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D

                            channelD = bufferValues;

                        otherwise

                            % Do nothing

                    end
                    
                end
                
            end
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getEtsBlockData: Data succesfully retrieved.\n');
                
            end
            
        else
            
            error('getEtsBlockData: Error retrieving data values - code: %d', getValuesStatus);
            
        end
        
        
    else
        
        error('getEtsBlockData: Aggregate Mode data collection not supported by this function.');
        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('\n');
        
    end</MCode>
               </Code>
               <Description>getEtsBlockData(obj, startIndex, segmentIndex, ratio, ratioMode) returns Equivalent Time Sampling (ETS) block mode data with or without downsampling starting at the specified sample number.

Memory for the data arrays is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode  is NOT supported by this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
startIndex - a zero-based index that indicates the start point for data collection.
segmentIndex - the number of the memory segment to be used/where the data is stored.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by enumeration from the PS5000A_RATIO_MODE excluding PS5000A_RATIO_MODE_AGGREGATE).


Output parameters:

numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
etsTimes - an array containing the times (in femtoseconds) at which each sample was captured.
channelA - an array containing data values (in millivolts) for channel A.
channelB - an array containing data values (in millivolts) for channel B.
channelC - an array containing data values (in millivolts) for channel C.
channelD - an array containing data values (in millivolts) for channel D.

Channels not enabled or not supported by this device will be returned as an empty array.

Please also refer to the ps5000aSetEtsTimeBuffer, ps5000aSetDataBuffer and ps5000aGetValues functions as well as the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValues</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNumSamples = libpointer('uint32Ptr', noOfSamples);
    pOverflow = libpointer('int16Ptr', 0);
    
    [status, ~, ~] = calllib('ps5000a', 'ps5000aGetValues', ...
                        deviceObj.DriverData.unitHandle, startIndex, pNumSamples, downSampleRatio, ....
                        downSampleRatioMode, segmentIndex, pOverflow);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetValues:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    else
        
        numSamples = pNumSamples.Value;
        overflow = pOverflow.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex) returns block-mode data, with or without downsampling, starting at the specified sample number.

Input parameters:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
segmentIndex - the zero-based number of the memory segment where the data is stored.

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

For further information on the ps5000aGetValues function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesOverlapped</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValuesOverlapped(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pOverflow = libpointer('int16Ptr', 0);
    
    [status, numSamples] = calllib('ps5000a', 'ps5000aGetValuesOverlapped', deviceObj.DriverData.unitHandle, ...
        startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex, pOverflow);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetValuesOverlapped:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end
    
    overflow = pOverflow.Value;</MCode>
               </Code>
               <Description>ps5000aGetValuesOverlapped(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex) allows you to make a deferred data-collection request, which will later be executed, and the arguments validated, when you call runBlock in block mode.

Input parameters:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required. 
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
segmentIndex - the zero-based number of the memory segment where the data is stored.

Output parameters:

status - status code returned by the driver.
numSamples - the actual number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

For further information on the ps5000aGetValuesOverlapped function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aIsReady</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ready] = ps5000aIsReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pReady = libpointer('int16Ptr', 0);

    [status] = calllib('ps5000a', 'ps5000aIsReady', ...
                        deviceObj.DriverData.unitHandle, pReady);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aIsReady:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    else
        
        ready = pReady.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aIsReady(obj) may be used to poll the driver  to see if it has finished collecting the requested samples after ps5000aRunBlock has been called.

Input parameters:

obj - the object representing the Block group.

Output parameters:

status - status code returned by the driver.
ready - indicates the state of the collection. If zero, the device is still collecting. If non-zero, the device has finished collecting and ps5000aGetValues can be used to retrieve the data.

For further information on the ps5000aIsReady function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aRunBlock</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aRunBlock(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    timebaseIndex = deviceObj.DriverData.timebase;
    preTriggerSamples = deviceObj.DriverData.numPreTriggerSamples;
    postTriggerSamples = deviceObj.DriverData.numPostTriggerSamples;
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('ps5000aRunBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n\n', ...
            timebaseIndex, preTriggerSamples, postTriggerSamples);
        
    end

    [status, timeIndisposedMs] = calllib('ps5000a', 'ps5000aRunBlock', ...
        deviceObj.DriverData.unitHandle, preTriggerSamples, postTriggerSamples, ...
        timebaseIndex, timeIndisposedMs, segmentIndex, lpReady, pParameter);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aRunBlock:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>runBlock(obj, segmentIndex) starts collecting data in block mode.

Input parameters:

obj - the object representing the Block group.
segmentIndex - zero-based index, specifying which memory segment to use.

Output parameters:

status - 0 if the ps5000aRunBlock function has been executed correctly. 

For further information on the  ps5000aRunBlock function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aSetEts</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleTimePicoSeconds] = ps5000aSetEts(obj, mode, etsCycles, etsInterleave)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pSampleTimePicoSeconds = libpointer('int32Ptr', 0); % Initialise to pass as pointer
    
    if (mode == deviceObj.DriverData.enums.enPS5000AEtsMode.PS5000A_ETS_OFF)
        
        [status, ~] = calllib('ps5000a', 'ps5000aSetEts', deviceObj.DriverData.unitHandle, ...
                    mode, etsCycles, etsInterleave, pSampleTimePicoSeconds);
                
        if (status ~= PicoStatus.PICO_OK)
           
            error('ps5000aSetEts:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
        end
                
        sampleTimePicoSeconds = pSampleTimePicoSeconds.Value;
    
    elseif (etsCycles &gt; 0 &amp;&amp; etsInterleave &gt; 0)
    
        switch (deviceObj.InstrumentModel)

                case {deviceObj.DriverData.constants.MODEL_PS5242A, deviceObj.DriverData.constants.MODEL_PS5442A, ...
                        deviceObj.DriverData.constants.MODEL_PS5242B, deviceObj.DriverData.constants.MODEL_PS5442B}

                    if (etsCycles &gt; deviceObj.DriverData.constants.PS5242A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 125).')
                           
                    end
                    
                    if (etsInterleave &gt; deviceObj.DriverData.constants.PS5242A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 10).')
                        
                    end
                    
                case {deviceObj.DriverData.constants.MODEL_PS5243A, deviceObj.DriverData.constants.MODEL_PS5443A, ...
                        deviceObj.DriverData.constants.MODEL_PS5243B, deviceObj.DriverData.constants.MODEL_PS5443B}

                    if (etsCycles &gt; deviceObj.DriverData.constants.PS5243A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 250).')
                           
                    end
                    
                    if (etsInterleave &gt; deviceObj.DriverData.constants.PS5243A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 20).')
                        
                    end
                    
                case {deviceObj.DriverData.constants.MODEL_PS5244A, deviceObj.DriverData.constants.MODEL_PS5444A, ...
                        deviceObj.DriverData.constants.MODEL_PS5244B, deviceObj.DriverData.constants.MODEL_PS5444B, ...
                        deviceObj.DriverData.constants.MODEL_PS5444B_034}

                    if (etsCycles &gt; deviceObj.DriverData.constants.PS5244A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 500).')
                           
                    end
                    
                    if (etsInterleave &gt; deviceObj.DriverData.constants.PS5244A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 40).')
                        
                    end
                    
                case {deviceObj.DriverData.constants.MODEL_PS5242D, deviceObj.DriverData.constants.MODEL_PS5442D, ...
                        deviceObj.DriverData.constants.MODEL_PS5242D_MSO, deviceObj.DriverData.constants.MODEL_PS5442D_MSO}

                    if (etsCycles &gt; deviceObj.DriverData.constants.PS5X42D_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 125).')
                           
                    end
                    
                    if (etsInterleave &gt; deviceObj.DriverData.constants.PS5X42D_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 5).')
                        
                    end
                    
                case {deviceObj.DriverData.constants.MODEL_PS5243D, deviceObj.DriverData.constants.MODEL_PS5443D, ...
                        deviceObj.DriverData.constants.MODEL_PS5243D_MSO, deviceObj.DriverData.constants.MODEL_PS5443D_MSO}

                    if (etsCycles &gt; deviceObj.DriverData.constants.PS5X43D_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 250).')
                           
                    end
                    
                    if (etsInterleave &gt; deviceObj.DriverData.constants.PS5X43D_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 40).')
                        
                    end
                    
                case {deviceObj.DriverData.constants.MODEL_PS5244D, deviceObj.DriverData.constants.MODEL_PS5444D, ...
                        deviceObj.DriverData.constants.MODEL_PS5244D_MSO, deviceObj.DriverData.constants.MODEL_PS5444D_MSO}

                    if (etsCycles &gt; deviceObj.DriverData.constants.PS5X44D_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 500).')
                           
                    end
                    
                    if (etsInterleave &gt; deviceObj.DriverData.constants.PS5X44D_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 80).')
                        
                    end
        
            otherwise
        
                % Do nothing
        end
        
        [status, ~] = calllib('ps5000a', 'ps5000aSetEts', deviceObj.DriverData.unitHandle, ...
                        mode, etsCycles, etsInterleave, pSampleTimePicoSeconds);
        
        if (status ~= PicoStatus.PICO_OK)
           
            error('ps5000aSetEts:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
        end
        
        sampleTimePicoSeconds = pSampleTimePicoSeconds.Value;
        
    else
        
        error('ps5000aSetEts: etsCycles and etsInterleave must both be greater than 0.')
        
    end</MCode>
               </Code>
               <Description>ps5000aSetEts(obj, mode, etsCycles, etsInterleave) is used to enable or disable ETS (equivalent-time sampling) and to set the ETS parameters.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
mode - must be one of the following:

	PS5000A_ETS_OFF    (0)
	PS5000A_ETS_FAST  (1)
	PS5000A_ETS_SLOW (2)

etsCycles - the number of cycles to store; must be greater than zero and between 2 and 5 times greater than etsInterleave.
etsInterleave - the number of waveforms to combine into a single ETS capture. Must be greater than zero.

Output parameters:

status - status code returned by the driver.
sampleTimePicoSeconds - the effective sampling interval of the ETS data.

For further information on the ps5000aSetEts function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetEtsTimeBuffer</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, etsBuffer] = ps5000aSetEtsTimeBuffer(obj, bufferLth)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Pointer to array
    pBuffer = libpointer('int64Ptr', zeros(bufferLth, 1, 'int64'));

    status = calllib('ps5000a', 'ps5000aSetEtsTimeBuffer', ...
                        deviceObj.DriverData.unitHandle, pBuffer, bufferLth);
    
    etsBuffer = pBuffer.Value;
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetEtsTimeBuffer:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetEtsTimeBuffer(obj, bufferLth) tells the driver where to find your application's ETS time buffers.

If using a 32-bit version of MATLAB, use ps5000aSetEtsTimeBuffers instead.

Input parameters:

obj - the object representing the Block group.
bufferLth - the number of ETS samples.

Output parameters:

status - status code returned by the device.
etsBuffer - a 1-D array of 64-bit words, each representing the time in femtoseconds at which the sample was captured.

For further information on the ps5000aSetEtsTimeBuffer function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aSetEtsTimeBuffers</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, etsTimeUpper, etsTimeLower] = ps5000aSetEtsTimeBuffers(obj, bufferLth)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Pointer to arrays
    pBufferUpper = libpointer('int32Ptr', zeros(bufferLth, 1));
    pBufferLower = libpointer('int32Ptr', zeros(bufferLth, 1));

    status = calllib('ps5000a', 'ps5000aSetEtsTimeBuffers', ...
                deviceObj.DriverData.unitHandle, pBufferUpper, pBufferLower, bufferLth);
    
    etsTimeUpper = pBufferUpper.Value;
    etsTimeLower = pBufferLower.Value;
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetEtsTimeBuffer:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetEtsTimeBuffers(obj, bufferLth) tells the driver where to find your application's ETS time buffers. These buffers contain the timing information for each ETS sample after you run a block mode ETS capture.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
bufferLth - the number of ETS samples.

Output parameters:

status - status code returned by the device.
etsTimeUpper - an array of 32-bit words, each representing the upper 32 bits of the time in femtoseconds at which the sample was captured.
etsTimeLower - an array of 32-bit words, each representing the lower 32 bits of the time in femtoseconds at which the sample was captured.

For further information on the ps5000aSetEtsTimeBuffers function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>runBlock</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIndisposedMs] = runBlock(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    timebaseIndex = deviceObj.DriverData.timebase;
    preTriggerSamples = deviceObj.DriverData.numPreTriggerSamples;
    postTriggerSamples = deviceObj.DriverData.numPostTriggerSamples;
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n\n', ...
            timebaseIndex, preTriggerSamples, postTriggerSamples);
    
    end

    [runBlockStatus, timeIndisposedMs] = calllib('ps5000a', 'ps5000aRunBlock', ...
        deviceObj.DriverData.unitHandle, preTriggerSamples, postTriggerSamples, ...
        timebaseIndex, segmentIndex, timeIndisposedMs, lpReady, pParameter);
    
    if (runBlockStatus ~= PicoStatus.PICO_OK)
           
        error('runBlock: Error in ps5000aRunBlock call - code %d', runBlockStatus); 
        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock: Waiting for device to become ready...\n');
        
    end
    
    ready = 0; % Initialise value for pointer
    pReady = libpointer('int16Ptr', ready);
    
    while (ready == 0)
        
        [readyStatus] = calllib('ps5000a', 'ps5000aIsReady', ...
                            deviceObj.DriverData.unitHandle, pReady);
                        
        ready = pReady.Value;
                        
        if (readyStatus ~= PicoStatus.PICO_OK)
           
            error('runBlock: Error in ps5000aIsReady call - code %d', readyStatus); 
        
        end
                        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock: Device ready.\n\n');
        
    end
    
    % Other conditions would have been captured.
    if (runBlockStatus == PicoStatus.PICO_OK &amp;&amp; readyStatus == PicoStatus.PICO_OK)
        
        status = PicoStatus.PICO_OK;
        
    else
        
        if (runBlockStatus ~= PicoStatus.PICO_OK)
            
            error('runBlock:- ps5000aRunBlock error code: %d\n', runBlockStatus);
            
        else
            
            error('runBlock:- ps5000aIsReady error code: %d\n', readyStatus);
                
        end
            
        
    end</MCode>
               </Code>
               <Description>runBlock(obj, segmentIndex) starts collecting data in block mode and returns when the device is ready for data to be collected.

Use this function when no further action is required between the start of data collection and retrieval of data from the device.

If additional functions need to be called in your script while waiting for the data to be collected, call the ps5000aRunBlock function, followed by the other required commands, and poll the device using the ps5000aIsReady function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
segmentIndex - zero-based index, specifying which memory segment to use.

Output parameters:

status - 0 if the ps5000aRunBlock and ps5000aIsReady functions have been executed correctly. 

For further information on the  ps5000aRunBlock and ps5000aIsReady functions please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.



</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>digital</Name>
         <Description>The Digital group contains a set of properties and functions related to the digital ports of the device (applicable to MSO models only).</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Digital1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>maxLogicLevel</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.maxLogicLevel;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>32767</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum count level for a digital port (corresponding to +5 V).</Description>
            </Property>
            <Property>
               <Name>minLogicLevel</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.minLogicLevel;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>-32767</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The minimum count level for a digital port (corresponding to -5 V).</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>getDigitalPortSettings</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, enabled, logicLevel] = getDigitalPortSettings(obj, port)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    logicLevelCounts = 0;
    
    % Verify that the digital port is valid, and if so, obtain the
    % information from the digitalPortSettings structure belonging to the
    % device.
    switch (port)
        
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0
            
            enabled          = deviceObj.DriverData.digitalPortSettings(1, 1);
            logicLevelCounts = deviceObj.DriverData.digitalPortSettings(1, 2);
            
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT1
            
            enabled          = deviceObj.DriverData.digitalPortSettings(2, 1);
            logicLevelCounts = deviceObj.DriverData.digitalPortSettings(2, 2);
            
        otherwise
       
            error('PS5000AGetDigitalPortSettings:InvalidDigitalPort', ...
                'getDigitalPortSettings - Invalid Digital port');
    end

    logicLevel = (logicLevelCounts / deviceObj.DriverData.constants.PS5000A_MAX_LOGIC_LEVEL ) ...
        * deviceObj.DriverData.constants.PS5000A_MAX_LOGIC_VOLTAGE ;
    
    status = PicoStatus.PICO_OK;</MCode>
               </Code>
               <Description>getDigitalPortSettings(obj, port) returns the settings for the digital port specified.

This function is for MSO devices only.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Digital group.
port - the port for digital data (either the enumeration enPS5000AChannel.PS5000A_DIGITAL_PORT0 or enPS5000AChannel.PS5000A_DIGITAL_PORT1).

Output Arguments:

status - status code returned by the driver.
enabled - TRUE (1) if the port is enabled, FALSE (0) otherwise.
logicLevel - the voltage at which the state transitions between 0 and 1. Range: -5 V to 5 V.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDigitalPort</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetDigitalPort(obj, port, enabled, logicLevel)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    logicLevelCount = int16((logicLevel / deviceObj.DriverData.constants.PS5000A_MAX_LOGIC_VOLTAGE) ...
        * deviceObj.DriverData.maxLogicLevel);
    
    status = calllib('ps5000a', 'ps5000aSetDigitalPort', ...
        deviceObj.DriverData.unitHandle, port, enabled, logicLevelCount);
    
    % Obtain digital port settings information 
    dpSettings = deviceObj.DriverData.digitalPortSettings;
    
    % Only process if status is ok.
	if (status == PicoStatus.PICO_OK)
        
        switch (port)
            
            case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0
                
                dpSettings(1,1) = enabled;
                dpSettings(1,2) = logicLevelCount;
                
            case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT1
                
                dpSettings(2,1) = enabled;
                dpSettings(2,2) = logicLevelCount;
                
             otherwise
                
                % Do nothing
                    
        end
        
        deviceObj.DriverData.digitalPortSettings = dpSettings;
        
        % Information to be passed to the wrapper dll
        enabledDigitalPorts = zeros(PicoConstants.DUAL_SCOPE, 1, 'int16');
        
        enabledDigitalPorts = [dpSettings(1,1); dpSettings(2,1)];
        
        % Pass information to wrapper dll
        setEnabledDigitalPortsStatus = calllib('ps5000aWrap', 'setEnabledDigitalPorts', ...
            deviceObj.DriverData.unitHandle, enabledDigitalPorts);
                
    else
       
        error('ps5000aSetDigitalPort: status code %d\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDigitalPort(obj, port, enabled, logicLevel) is used to enable the digital port and set the logic level (the voltage point at which the state transitions from 0 to 1 for a digital channel).

This function is for MSO devices only and is not compatible with ETS mode.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Digital group.
port - the port for digital data (either the enumeration enPS5000AChannel.PS5000A_DIGITAL_PORT0 or enPS5000AChannel.PS5000A_DIGITAL_PORT1).
enabled - set to TRUE (1) to enable the channel, FALSE (0) otherwise.
logicLevel - the voltage at which the state transitions between 0 and 1. Range: -5 V to 5 V.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>setDigitalPortDefaults</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setDigitalPortDefaults(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('Default Digital Port Setup:-\n');
        fprintf('----------------------------\n\n');
        
    end

    dPort0 = deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0;
    dPort1 = deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT1;
    
    true = PicoConstants.TRUE;
    logicLevelVoltage = 1.5; % Default value (Volts)
    
    % Matrix of values to represent digital ports (rows) x properties (cols)
    deviceObj.DriverData.digitalPortSettings = zeros(deviceObj.DriverData.digitalPortCount, 2);

    % Set Digital Ports count updating internal settings
    % Parameters are enabled and logic level.

    % Update internal settings
    
    % Create a number of ports x fields array
    dpSettings = zeros(deviceObj.DriverData.digitalPortCount, 2);
    
    for ch = 1:deviceObj.DriverData.digitalPortCount
        
        digiPortSettings(ch).enabled = true;
        digiPortSettings(ch).logicLevel = logicLevelVoltage;
        
        % Transpose the resulting array for the channel and combine
        dpSettings(ch, :) = cell2mat(struct2cell(digiPortSettings(ch)))';

    end
    
    deviceObj.DriverData.digitalPortSettings = dpSettings;
    
    status = zeros(deviceObj.DriverData.digitalPortCount, 1);
    
    status(1) = invoke(obj, 'ps5000aSetDigitalPort', dPort0, true, logicLevelVoltage);
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('PORT0:-\n\tEnabled: True\n\tLogic Level: +1.5 V\n\n');
        
    end

    status(2) = invoke(obj, 'ps5000aSetDigitalPort', dPort1, true, logicLevelVoltage);
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('PORT1:-\n\tEnabled: True\n\tLogic Level: +1.5 V\n\n');
        
    end

    % Clear local variables
    
    clear true;
    clear logicLevel;</MCode>
               </Code>
               <Description>setDigitalPortDefaults(obj) sets the following default values for any digital ports found on the device:

Digital Port:

Enabled               : True
Logic Level	: +1.5 V

Input Arguments:

obj - the object representing the Digital group.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>rapidblock</Name>
         <Description>The Rapidblock group contains a set of properties and functions related to the rapid block mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Rapidblock1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getRapidBlockData</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, channelA, channelB, channelC, channelD, dPort0, dPort1] = getRapidBlockData(obj, numCaptures, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS5000ARatioMode.PS5000A_RATIO_MODE_AGGREGATE)
        
        unitHandle = deviceObj.DriverData.unitHandle;

        channelCount = deviceObj.DriverData.channelCount;

        portCount = deviceObj.DriverData.digitalPortCount;
        
        % Retrieve channel settings - channel x data field matrix.
        channelSettings = deviceObj.DriverData.channelSettings;
    
        % Retrieve port settings - port x data field matrix.
        portSettings = deviceObj.DriverData.digitalPortSettings;
        
        % For 4-channel models verify power supply is connected.
        % Only 2-channels are enabled if the power supply is not connected.
        if (channelCount == PicoConstants.QUAD_SCOPE)
        
            currentPowerState = calllib('ps5000a', 'ps5000aCurrentPowerSource', unitHandle);
        
            if (currentPowerState == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
           
                channelCount = PicoConstants.DUAL_SCOPE;
                
            end
            
        end
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];
        
        dPort0 = [];
        dPort1 = [];

        % Initialise variables for array of libpointers
        
        % Analogue channels
        pABuffer(channelCount, numCaptures) = libpointer;
        
        % Digital ports
        if (portCount &gt; 0)

            pDBuffer(portCount, numCaptures) = libpointer;

        end
        
        % Initialise array for status values
        setBufferStatus = zeros(channelCount, numCaptures, 'uint32');

        % Total number of samples to set for data buffers, taking into
        % account the downsampling ratio
        totalSamples = ceil((deviceObj.DriverData.numPreTriggerSamples + deviceObj.DriverData.numPostTriggerSamples) / ratio);
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getRapidBlockData: Setting up data buffers...\n');
            
        end
        
        % Create a 2D matrix of libpointers to allocate memory space for
        % each channel and segment combination
        
        % Iterate down rows in inner loop      
        for segment = 1:numCaptures
            
            for ch = 1:channelCount
                
                % Set Data Buffer if channel is enabled
                if (channelSettings(ch,1) == PicoConstants.TRUE)
                    
                    % Store array of libpointers
                    pABuffer(ch, segment) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));
                    
                    setBufferStatus(ch, segment) = calllib('ps5000a', 'ps5000aSetDataBuffer', unitHandle, ...
                        (ch - 1), pABuffer(ch, segment), totalSamples, (segment - 1), ratioMode);

                    if (setBufferStatus(ch, segment) ~= PicoStatus.PICO_OK)

                        error('getRapidBlockData: Set Data Buffer for Channel %d Segment % error code %d', ...
                            (ch - 1), (segment - 1), setBufferStatus);

                    end
                    
                end
                
            end

            if (portCount &gt; 0)
                
                % Repeat for Digital ports
                for port = 1:portCount

                    % Set Data Buffer if channel is enabled - index 1 indicates if
                    % channel is enabled
                    if (portSettings(port,1) == PicoConstants.TRUE)

                        % Store array of libpointers
                        pDBuffer(port, segment) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                        setBufferStatus = calllib('ps5000a', 'ps5000aSetDataBuffer', ...
                            unitHandle, (port - 1 + deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0), ... 'PORT0 = 128, PORT1 = 129
                            pDBuffer(port, segment), totalSamples, (segment-1), ratioMode);

                        if (setBufferStatus ~= PicoStatus.PICO_OK)

                            error('getRapidBlockData:- Set Data Buffer for Port %d Segment % status code: %d', ...
                                (port - 1), (segment - 1), setBufferStatus);

                        end

                    end

                end
                
            end
            
        end

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getRapidBlockData: Retrieving data...\n');
            
        end
        
        fromSegmentIndex = 0;
        toSegmentIndex = numCaptures - 1;
        
        overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
        overflowPtr = libpointer('int16Ptr', zeros(overflowSize, 1, 'int16'));
        overflow = 0;

        [getValuesBulkStatus, numSamples] = calllib('ps5000a', 'ps5000aGetValuesBulk', ...
            unitHandle, totalSamples, fromSegmentIndex, toSegmentIndex, ratio, ratioMode, overflowPtr);
        
        overflow = overflowPtr.Value;
        
        if (getValuesBulkStatus == PicoStatus.PICO_OK)
            
            if (portCount &gt; 0 &amp;&amp; deviceObj.DriverData.displayOutput == PicoConstants.TRUE)

                fprintf('getRapidBlockData: Retrieving digital port data and assigning to port array.\n');

            end
            
            for port = 1:portCount

                if (portSettings(port,1) == PicoConstants.TRUE)

                    % Obtain a cell array representing the waveforms for
                    % the channel
                    bufferCells = get(pDBuffer(port, :), 'Value');

                    % Combine the cell contents into a total_samples x
                    % numCaptures array               
                    if (numCaptures &gt; 1)

                        bufferCells = horzcat(bufferCells{1:end});                    

                    end

                    switch (port - 1 + deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0)

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT0

                            dPort0 = bufferCells;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_DIGITAL_PORT1

                            dPort1 = bufferCells;

                        otherwise

                            % Do nothing

                    end

                end

            end
            
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getRapidBlockData: Converting to millivolts and assigning to channel array.\n');
                
            end
            
            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);
            
            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)
                    
                    scopeInputIndex = channelSettings(ch,3) + 1;
                    voltageRange = PicoConstants.SCOPE_INPUT_RANGES(scopeInputIndex);
                    
                    % Obtain a cell array representing the waveforms for 
                    % the channel.
                    
                    bufferCell = get(pABuffer(ch, :), 'Value');
                    
                    % Combine the cell contents into a totalSamples x
                    % numCaptures array.
                    
                    bufferMatrix = [];
                    
                    if (numCaptures &gt; 1)
                        
                        bufferMatrix = horzcat(bufferCell{1:end});
                        
                    else
                       
                        bufferMatrix = bufferCell;
                        
                    end
                   
                    bufferValues = adc2mv(bufferMatrix, voltageRange, maxADCValue);
                    
                    switch (ch - 1)

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D

                            channelD = bufferValues;

                        otherwise

                            % Do nothing

                    end
                    
                    clear bufferCell;
                    clear bufferMatrix;
                    clear bufferValues;
                    
                end
                
            end
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getRapidBlockData: Data succesfully retrieved.\n\n');
                
            end
            
            clear pABuffer;
            
            if (portCount &gt; 0)

                clear pDBuffer;

            end
            
        else
            
            error('getRapidBlockData: Error retrieving data values - code: %d', getValuesBulkStatus);
            
        end
        
        
    else
        
        error('getRapidBlockData: Aggregate Mode data collection not supported by this function.');
        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
    
        fprintf('\n');
        
    end
</MCode>
               </Code>
               <Description>getBlockData(obj, numCaptures, ratio, ratioMode) retrieves waveforms captured using rapid block mode. The waveforms must have been collected sequentially and in the same run.

Memory for the data arrays from segment index 0 to numCaptures - 1 is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode  is NOT supported by this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by enumeration from the enPS5000aRatioMode range excluding PS5000A_RATIO_MODE_AGGREGATE).

Output parameters:

status - status code returned by the driver.
numSamples -the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
channelA - a matrix containing data values (in millivolts) for channel A.
channelB - a matrix containing data values (in millivolts) for channel B.
channelC - a matrix containing data values (in millivolts) for channel C.
channelD - a matrix containing data values (in millivolts) for channel D.
portD0 - a matrix containing data values in binary format for digital Port 0 (in MSB order)
portD1 - a matrix containing data values in binary format for digital Port 1 (in MSB order)

Channel data will be returned as a matrix in the form numSamples x numCaptures. Channels not enabled or not supported by this device will be returned as an empty array.

Please also refer to the  ps5000aSetDataBuffer and ps5000aGetValues functions.</Description>
            </Method>
            <Method>
               <Name>getTriggerInfoBulk</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, triggerInfo] = getTriggerInfoBulk(obj, triggerInfo, fromSegmentIndex, toSegmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

deviceObj = get(obj, 'Parent');

pTriggerInfo = libpointer('tPS5000ATriggerInfoPtr',triggerInfo);
%%
status = calllib('ps5000a', 'ps5000aGetTriggerInfoBulk', deviceObj.DriverData.unitHandle, pTriggerInfo, fromSegmentIndex, toSegmentIndex);

if (status ~= PicoStatus.PICO_OK)
    error('Picotech:PS5000AInstrumentDriver:ps5000aGetTriggerInfoBulk', ...
                    ['ps5000aGetTriggerInfoBulk has returned status code ', ...
                     num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
end

%%
triggerInfo(1)=pTriggerInfo.Value;

for i = 1:(toSegmentIndex-fromSegmentIndex)
    TriggerInfoPtrInc = pTriggerInfo+i;
    triggerInfo(i+1) = TriggerInfoPtrInc.Value;
end</MCode>
               </Code>
               <Description>getTriggerInfoBulk(obj, triggerInfo, fromSegmentIndex, toSegmentIndex) retrieves the trigger infromation from waveforms captured during a rapid block capture

Input Parameters

obj - the device group object
triggerInfo - structure array of 1 or more MATLAB structures corresponding to the tPS5000ATriggerInfo structure (accessable from the PS5000AStructs struct)
fromSegmentIndex - integer relating to the first segement to retrieve trigger data from
toSegmentIndex - integer relating to the last segment to retrieve tirgger data from

Function Outputs

status - status code returned by the device.
triggerInfo -  structure array of 1 or more MATLAB structures corresponding to the tPS5000ATriggerInfo structure (accessable from the PS5000AStructs struct) that has been populated with the trigger info data</Description>
            </Method>
            <Method>
               <Name>ps5000aGetNoOfCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nCaptures] = ps5000aGetNoOfCaptures(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNCaptures = libpointer('uint32Ptr', 0); % Value for pointer.

    [status] = calllib('ps5000a', 'ps5000aGetNoOfCaptures', ...
                           deviceObj.DriverData.unitHandle, pNCaptures);
                        
    if(status ~= PicoStatus.PICO_OK)
           
       error('ps5000aGetNoOfCaptures:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    else
        
        nCaptures = pNCaptures.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetNoOfCaptures(obj) finds out how many captures are available in rapid block mode after runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps5000aStop.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.

Output parameters:

status - status code returned by the driver.
nCaptures - the number of available captures that has been collected from calling runBlock.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetNoOfProcessedCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nProcessedCaptures] = ps5000aGetNoOfProcessedCaptures(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNumProcessedCaptures = libpointer('uint32Ptr', 0); % Value for pointer.

    [status] = calllib('ps5000a', 'ps5000aGetNoOfProcessedCaptures', ...
                    deviceObj.DriverData.unitHandle, pNumProcessedCaptures);
    
    if(status ~= PicoStatus.PICO_OK)
           
       error('ps5000aGetNoOfProcessedCaptures:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    else
        
        nProcessedCaptures = pNumProcessedCaptures.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetNoOfProcessedCaptures(obj, nCaptures) finds out how many captures in rapid block mode have been processed after runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps5000aStop.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.

Output parameters:

status - status code returned by the driver.
nProcessedCaptures - the number of available captures that has been collected from calling runBlock.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesBulk</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValuesBulk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNumSamples = libpointer('uint32Ptr', noOfSamples);
    
    % overflow must be an array
    overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
    pOverflow = libpointer('int16Ptr', zeros(overflowSize, 1));
    overflow = 0;

    [status] = calllib('ps5000a', 'ps5000aGetValuesBulk', ...
                deviceObj.DriverData.unitHandle, pNumSamples, fromSegmentIndex, ...
                toSegmentIndex, downSampleRatio, downSampleRatioMode, pOverflow);
    
    if (status ~= PicoStatus.PICO_OK)
        
        error('ps5000aGetValuesBulk:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    else
           
        numSamples = pNumSamples.Value;
        overflow = pOverflow.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesBulk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode) retrieves waveforms captured using rapid block mode.

Input parameters:

obj - the object representing the Rapidblock group.
noOfSamples - the number of samples required per channels in each segment.
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved per channel in each segment.
overflow - an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overlow value as described in the ps5000aGetValues function.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesOverlappedBulk</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValuesOverlappedBulk(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, fromSegmentIndex, toSegmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNumSamples = libpointer('uint32Ptr', noOfSamples);
    
    % overflow must be an array
    overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
    pOverflow = libpointer('int16Ptr', zeros(overflowSize, 1));
    overflow = 0;
    
    [status] = calllib('ps5000a', 'ps5000aGetValuesOverlappedBulk', deviceObj.DriverData.unitHandle, ...
        startIndex, pNumSamples, downSampleRatio, downSampleRatioMode, fromSegmentIndex, ...
        toSegmentIndex, pOverflow);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetValuesOverlappedBulk:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    else
           
        numSamples = pNumSamples.Value;
        overflow = pOverflow.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesOverlappedBulk(obj, startIndex, pNoOfSamples, downSampleRatio, downSampleRatioMode, fromSegmentIndex, toSegmentIndex, pOverflow) allows you to make a deferred data-collection request, which will later be executed, and the arguments validated, when you call runBlock in rapid block mode.

Input parameters:

obj - the object representing the Rapidblock group.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required per channels in each segment.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved per channel in each segment.
overflow - an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overlow value as described in the ps5000aGetValues function.
</Description>
            </Method>
            <Method>
               <Name>ps5000aSetNoOfCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetNoOfCaptures(obj, nCaptures)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps5000a', 'ps5000aSetNoOfCaptures', ...
        deviceObj.DriverData.unitHandle, nCaptures);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetNoOfCaptures:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetNoOfCaptures(obj, nCaptures) sets the number of captures to be collected in one run of rapid block mode.

If this function is not called prior to a run, only a single waveform will be captured.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.
nCaptures - the number of waveforms to capture in one run.

Output parameters:

status - status code returned by the device.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>signalgenerator</Name>
         <Description>The Signalgenerator group contains a set of properties and functions related to the signal generator functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Signalgenerator1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>awgBufferSize</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.awgBufferSize;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="49152.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The size of the arbitrary waveform buffer on the device, in samples. Applies only to the 'B' and 'D' variants in the PicoScope 5000 Series range.

</Description>
            </Property>
            <Property>
               <Name>dacFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.dacFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>20000000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>dacFrequency is the update frequency of the Arbitrary Waveform Generator.</Description>
            </Property>
            <Property>
               <Name>offsetVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.offsetVoltage;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.offsetVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2000.0" Min="-2000.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The voltage offset, in millivolts, to be applied to the waveform.

The amplitude of the waveform should not exceed +/-2000 mV.</Description>
            </Property>
            <Property>
               <Name>peakToPeakVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.peakToPeakVoltage;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.peakToPeakVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The peak-to-peak voltage, in millivolts, of the waveform signal.

The amplitude of the waveform should not exceed +/-2000 mV.</Description>
            </Property>
            <Property>
               <Name>sigGenType</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.sigGenType;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The type of Signal Generator on the device:

0 - None
1 - Function Generator
2 - Arbitrary Waveform Generator</Description>
            </Property>
            <Property>
               <Name>startFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.startFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.startFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.0E7" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency that the signal generator will initially produce (Hertz).</Description>
            </Property>
            <Property>
               <Name>stopFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.stopFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.stopFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.0E7" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency at which the sweep reverses direction or returns to the initial frequency (Hertz).

To output a signal with constant frequency, ensure that stopFrequency is equal to startFrequency.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps5000aSigGenSoftwareControl</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSigGenSoftwareControl(obj, state)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps5000a', 'ps5000aSigGenSoftwareControl', ...
                deviceObj.DriverData.unitHandle, state);
            
	if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSigGenSoftwareControl:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end </MCode>
               </Code>
               <Description>ps5000aSigGenSoftwareControl(obj, state) causes a trigger event, or starts and stops gating. Use it as follows:

1. Call ps5000aSetSigGenBuiltIn or ps5000aSetSigGenArbitrary to set up the signal generator, setting the triggerSource argument to PS5000A_SIGGEN_SOFT_TRIG. 

2. (a) If you set the signal generator triggerType to edge triggering (enPS5000ASigGenTrigType.PS5000A_SIGGEN_RISING or
enPS5000ASigGenTrigType.PS5000A_SIGGEN_FALLING), call ps5000aSigGenSoftwareControl once to trigger the signal generator.

(b) If you set the signal generator triggerType to gated-low triggering
(enPS5000ASigGenTrigType.PS5000A_SIGGEN_GATE_LOW), call ps5000aSigGenSoftwareControl with state = 0 to start the sweep and then again with state = 1 to stop it.

(c) If you set the signal generator triggerType to gated-high triggering
(enPS5000ASigGenTrigType.PS5000A_SIGGEN_GATE_HIGH), call ps5000aSigGenSoftwareControl with state = 1 to start the sweep and then again with state = 0 to stop it. 

This function may be used with the Test and Measurement Tool.

Input arguments:

obj - the object representing the Signalgenerator group.
state - specifies the new state of the gate signal. A change of state either starts or stops the sweep
depending on the triggerType, as detailed above. Effective only when the signal generator triggerType
is set to PS5000A_SIGGEN_GATE_HIGH or PS5000A_SIGGEN_GATE_LOW. Ignored for other trigger types. 

0: set the gate signal low
1: set the gate signal high

Output arguments:

status - status code returned by the driver.

For further information on the ps5000aSigGenSoftwareControl please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwellTime] = setSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Only call function if device has an Arbitrary Waveform Generator
    if (deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if (abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error(['setSigGenArbitrary: The sum of offsetVoltage and ' ...
                'peakToPeakVoltage cannot exceed +/-4000mV.']);
            
        end
        
        maxBufferSize = deviceObj.DriverData.awgBufferSize;
        dacFrequency = deviceObj.DriverData.dacFrequency;
        
        % Convert the waveform to the required range for the driver (-32768 to 32767)
        arbitrary_waveform = int16(arbitraryWaveform * double(deviceObj.DriverData.maxArbitraryWaveformValue));
        
        % Find the values which need to be converted to the minimum value
        minValues = find(arbitrary_waveform == (-1 * deviceObj.DriverData.maxArbitraryWaveformValue));
        arbitrary_waveform(minValues) = deviceObj.DriverData.minArbitraryWaveformValue;
        
        startFrequency = deviceObj.DriverData.startFrequency;

        % Convert start frequency to delta phase value
        pStartDeltaPhase = libpointer('uint32Ptr', 0);

        status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                      deviceObj.DriverData.unitHandle, startFrequency, ...
                      indexMode, length(arbitrary_waveform), pStartDeltaPhase); 
                  
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenArbitrary:- ps5000aSigGenFrequencyToPhase ' ...
                '(start frequency) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
          
        else
            
            startDeltaPhase = pStartDeltaPhase.Value;
            
        end
        
        stopDeltaPhase = 0;
        dwellCount = 0;

        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        stopFrequency = deviceObj.DriverData.stopFrequency;

        if (stopFrequency == startFrequency)

            stopDeltaPhase = startDeltaPhase;

        else

            % Convert stop frequency to delta phase
            pStopDeltaPhase = libpointer('uint32Ptr', 0);

            status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                        deviceObj.DriverData.unitHandle, stopFrequency, ...
                        indexMode, length(arbitrary_waveform), pStopDeltaPhase);  

            if (status ~= PicoStatus.PICO_OK)
                
                error(['setSigGenArbitrary:- ps5000aSigGenFrequencyToPhase ' ...
                    '(stop frequency) status code: %d. Please refer to the ' ...
                    'PicoStatus.m file.'], status);
                
            else

                stopDeltaPhase = pStopDeltaPhase.Value;
                
            end

        end
        
        % Convert increment frequency to delta phase value
        deltaPhaseIncrement = 0;
        
        if (increment &gt; 0)
            
            pDeltaPhaseIncrement = libpointer('uint32Ptr', 0);

            status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                deviceObj.DriverData.unitHandle, increment, indexMode, ... 
                length(arbitrary_waveform), pDeltaPhaseIncrement);

            if (status ~= PicoStatus.PICO_OK)

                error(['setSigGenArbitrary:- ps5000aSigGenFrequencyToPhase ' ...
                    '(increment freq.) status code: %d. Please refer to the ' ...
                    'PicoStatus.m file.'], status);

            end

            deltaPhaseIncrement = pDeltaPhaseIncrement.Value;
            
        end
        
        dwellCount = round(dwellTime * dacFrequency); % Round to the nearest integer

        if (dwellCount &lt; deviceObj.DriverData.constants.MIN_DWELL_COUNT)

            dwellCount = deviceObj.DriverData.constants.MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        dwellTime = dwellCount / dacFrequency;
        
        % Convert extInThresholdMV to counts if device is not an MSO model
        extInThreshold = 0;
        
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS5000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS5000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps5000a', 'ps5000aSetSigGenArbitrary', ...
                    deviceObj.DriverData.unitHandle, offsetVoltageUV, peakToPeakVoltageUV, startDeltaPhase, ...
                    stopDeltaPhase, deltaPhaseIncrement, dwellCount, arbitrary_waveform, ...
                    length(arbitrary_waveform), sweepType, operation, indexMode, shots, ...
                    sweeps, triggerType, triggerSource, extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)
                    
            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Conflict between the shots and sweeps parameters sent to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                    
                case PicoStatus.PICO_SIGGEN_INVALID_SWEEP_PARAMETERS
                    
                    error('setSigGenArbitrary: The sweeps or shots and trigger type are not valid when combined together.');
                    
                otherwise     
                    
                    error('setSigGenArbitrary: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
            end
            
        end
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, offsetVoltageMV, pkToPkMV, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV) programs the signal generator to produce an arbitrary waveform.

The offsetVoltage, peakToPeakVoltage, startFrequency and stopFrequency properties must be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input arguments:

obj - the object representing the Signalgenerator group.
increment - the increase or decrease in frequency (in hertz) when operating in sweep mode.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples in the range -1 to +1. These values correspond to the maximum and minimum amplitude values of the waveform.
sweepType - determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
operation - configures the white noise/PRBS (pseudo-random binary sequence) generator.
indexMode - specifies how the signal will be formed from the arbitrary waveform data.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
	then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value 
		then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - used to set the trigger level for the external trigger (in millivolts).

Output arguments:

status - status code returned by the driver.
dwellTime - the dwell time will be modified if the user specifies a dwell time corresponding to less than the minimum dwell count for the device (3).



 </Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrarySimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenArbitrarySimple(obj, arbitraryWaveform)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Only call function if device has an Arbitrary Waveform Generator
    if (deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if (abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error(['setSigGenArbitrary: The sum of offsetVoltage and ' ...
                'peakToPeakVoltage cannot exceed +/-4000mV.']);
            
        end
        
        maxBufferSize = deviceObj.DriverData.awgBufferSize;
        dacFrequency = deviceObj.DriverData.dacFrequency;
        
        % Convert the waveform to the required range for the driver (-32768 to 32767)
        arbitrary_waveform = int16(arbitraryWaveform * double(deviceObj.DriverData.maxArbitraryWaveformValue));
        
        % Find the values which need to be converted to the minimum value
        minValues = find(arbitrary_waveform == (-1 * deviceObj.DriverData.maxArbitraryWaveformValue));
        arbitrary_waveform(minValues) = deviceObj.DriverData.minArbitraryWaveformValue;

        % Convert frequency to delta phase
        pStartDeltaPhase = libpointer('uint32Ptr', 0);
        indexMode = deviceObj.DriverData.enums.enPS5000AIndexMode.PS5000A_SINGLE;
        
        status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                      deviceObj.DriverData.unitHandle, ...
                      deviceObj.DriverData.startFrequency, indexMode, ...
                      length(arbitrary_waveform), pStartDeltaPhase); 
        
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenArbitrarySimple:- ps5000aSigGenFrequencyToPhase ' ...
                '(frequency) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
            
        end
        
        startDeltaPhase = pStartDeltaPhase.Value;

        % Constant frequency
        stopDeltaPhase = startDeltaPhase;
        
        status = calllib('ps5000a', 'ps5000aSetSigGenArbitrary', ...
                    deviceObj.DriverData.unitHandle, offsetVoltageUV, peakToPeakVoltageUV, ...
                    startDeltaPhase, stopDeltaPhase, 0, 0, arbitrary_waveform, ...
                    length(arbitraryWaveform), 0, 0, 0, 0, 0, 0, 0, 0);
        
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Conflict between the shots and sweeps parameters sent to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                
                otherwise     
                    
                    error('setSigGenArbitrary: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
            end
            
        end
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end


</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, arbitraryWaveform) programs the signal generator to produce an arbitrary waveform at a constant frequency.

The offsetVoltage, peakToPeakVoltage, startFrequency and stopFrequency properties must be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input arguments:

obj - the object representing the Signalgenerator group.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples in the range -1 to +1. These values correspond to the maximum and minimum amplitude values of the waveform.

Output arguments:

status - status code returned by the driver.

For further information on the ps5000aSetSigGenArbitrary function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    sigGenType = deviceObj.DriverData.sigGenType;
    
    % Error checking
    if (sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        % Convert extInThresholdMV to counts if device is not an MSO model
        extInThreshold = 0;
        
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS5000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS5000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps5000a', 'ps5000aSetSigGenBuiltInV2', ...
                    deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, waveType, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.stopFrequency, ...
                    increment, dwellTime, sweepType, operation, shots, sweeps, ...
                    triggerType, triggerSource, extInThreshold);

        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)

            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltIn: Conflict between the shots and sweeps parameters sent to the signal generator.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltIn: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenBuiltIn: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltIn: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltIn: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltIn: Unable to setup signal generator waveform.');

                case PicoStatus.PICO_SIGGEN_INVALID_SWEEP_PARAMETERS
                    
                    error('setSigGenBuiltIn: The sweeps or shots and trigger type are not valid when combined together.');
                      
                otherwise     

                    error('setSigGenBuiltIn: Status code: %d. Please refer to the PicoStatus.m file.\n', dec2hex(status));
            end

        end
                
    else
        
        error('setSigGenBuiltIn: Signal Generator functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenBuiltIn(obj, offsetVoltageMV, pkToPkMV, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV) sets up the signal generator to produce a signal from a list of built-in waveforms.

The offsetVoltage, peakToPeakVoltage, startFrequency and stopFrequency properties must be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
wavetype - the type of waveform to be generated by the oscilloscope. Use the following enPS5000AWaveType enumerations:

A, B &amp; D Variants:

0 - PS5000A_SINE
1 - PS5000A_SQUARE
2 - PS5000A_TRIANGLE
8 - PS5000A_DC VOLTAGE

B &amp; D Variants only:

3 - PS5000A_RAMP UP
4 - PS5000A_RAMP DOWN
5 - PS5000A_SINC
6 - PS5000A_GAUSSIAN
7 - PS5000A_HALF SINE

increment - the amount in hertz by which the frequency rises or falls every dwellTime seconds in sweep mode.
dwellTime - the time in seconds between frequency changes in sweep mode.
sweepType - determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
operation - configures the white noise/PRBS (pseudo-random binary sequence) generator.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
		then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - used to set the trigger level for the external trigger (in millivolts).

Output arguments:

status - status code returned by the driver.

</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltInSimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltInSimple(obj, waveType)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
 
    deviceObj = get(obj, 'Parent');
    sigGenType = deviceObj.DriverData.sigGenType;
    
    % Error checking
    if (sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        status = calllib('ps5000a', 'ps5000aSetSigGenBuiltInV2', ...
                    deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, waveType, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.stopFrequency, ...
                        0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)

            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltInSimple: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltInSimple: Conflict between the shots and sweeps parameters sent to the signal generator.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltInSimple: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenBuiltInSimple: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltInSimple: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltInSimple: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltInSimple: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltInSimple: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
            end

        end  
    
    else
        
        error('setSigGenBuiltInSimple: Signal Generator functionality not supported by this device.');
        
    end
    </MCode>
               </Code>
               <Description>setSigGenBuiltInSimple(obj, offsetVoltageMV, pkToPkMV, waveType) sets up the signal generator to produce a signal of constant frequency from a list of built-in waveforms.

The offsetVoltage, peakToPeakVoltage, startFrequency and stopFrequency properties must be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input arguments:

obj - the object representing the Signalgenerator group.
wavetype - the type of waveform to be generated by the oscilloscope. Use the following enPS5000AWaveType enumerations:

A, B &amp; D Variants:

0 - PS5000A_SINE
1 - PS5000A_SQUARE
2 - PS5000A_TRIANGLE
8 - PS5000A_DC VOLTAGE

B &amp; D Variants only:

3 - PS5000A_RAMP UP
4 - PS5000A_RAMP DOWN
5 - PS5000A_SINC
6 - PS5000A_GAUSSIAN
7 - PS5000A_HALF SINE

Output arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>setSigGenOff</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
 
    deviceObj = get(obj, 'Parent');
    
    offsetVoltage = 0;
    pkToPk = 0;
    
    status = calllib('ps5000a', 'ps5000aSetSigGenBuiltIn', deviceObj.DriverData.unitHandle, ...
                offsetVoltage, pkToPk, deviceObj.DriverData.enums.enPS5000AWaveType.PS5000A_DC_VOLTAGE, 0, 0, ...
                0, 0, 0, 0, 0, 0, 0, 0, 0);
            
    if (status ~= PicoStatus.PICO_OK)
       
        error('setSigGenOff: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>setSigGenOff(obj) effectively turns off the signal generator by setting the output to a zero DC voltage.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.

Output parameters:

status - status code returned by the device.</Description>
            </Method>
            <Method>
               <Name>setSigGenPropertiesArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwellTime] = setSigGenPropertiesArbitrary(obj, increment, dwellTime, arbitraryWaveformSize, sweepType, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Only call function if device has an Arbitrary Waveform Generator
    if (deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        dacFrequency = deviceObj.DriverData.dacFrequency;
        
        startFrequency = deviceObj.DriverData.startFrequency;

        % Convert start frequency to delta phase value
        pStartDeltaPhase = libpointer('uint32Ptr', 0);

        status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                      deviceObj.DriverData.unitHandle, startFrequency, ...
                      indexMode, arbitraryWaveformSize, pStartDeltaPhase); 
                  
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenPropertiesArbitrary:- ps5000aSigGenFrequencyToPhase ' ...
                '(start frequency) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
          
        else
            
            startDeltaPhase = pStartDeltaPhase.Value;
            
        end
        
        stopDeltaPhase = 0;
        dwellCount = 0;

        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        stopFrequency = deviceObj.DriverData.stopFrequency;

        if (stopFrequency == startFrequency)

            stopDeltaPhase = startDeltaPhase;

        else

            % Convert stop frequency to delta phase
            pStopDeltaPhase = libpointer('uint32Ptr', 0);

            status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                        deviceObj.DriverData.unitHandle, stopFrequency, ...
                        indexMode, arbitraryWaveformSize, pStopDeltaPhase);  

            if (status ~= PicoStatus.PICO_OK)
                
                error(['setSigGenPropertiesArbitrary:- ps5000aSigGenFrequencyToPhase ' ...
                    '(stop frequency) status code: %d. Please refer to the ' ...
                    'PicoStatus.m file.'], status);
                
            else

                stopDeltaPhase = pStopDeltaPhase.Value;
                
            end

        end

        % Convert increment frequency to delta phase value
        deltaPhaseIncrement = 0;
        
        if (increment &gt; 0)
            
            pDeltaPhaseIncrement = libpointer('uint32Ptr', 0);

            status = calllib('ps5000a', 'ps5000aSigGenFrequencyToPhase', ...
                deviceObj.DriverData.unitHandle, increment, indexMode, ... 
                arbitraryWaveformSize, pDeltaPhaseIncrement);

            if (status ~= PicoStatus.PICO_OK)

                error(['setSigGenPropertiesArbitrary:- ps5000aSigGenFrequencyToPhase ' ...
                    '(increment freq.) status code: %d. Please refer to the ' ...
                    'PicoStatus.m file.'], status);

            end

            deltaPhaseIncrement = pDeltaPhaseIncrement.Value;
            
        end
        
        dwellCount = round(dwellTime * dacFrequency); % Round to the nearest integer

        if (dwellCount &lt; deviceObj.DriverData.constants.MIN_DWELL_COUNT)

            dwellCount = deviceObj.DriverData.constants.MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        dwellTime = dwellCount / dacFrequency;
        
        % Convert extInThresholdMV to counts if device is not an MSO model
        extInThreshold = 0;
        
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS5000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS5000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps5000a', 'ps5000aSetSigGenPropertiesArbitrary', ...
                    deviceObj.DriverData.unitHandle, startDeltaPhase, stopDeltaPhase, ...
                    deltaPhaseIncrement, dwellCount, sweepType, shots, ...
                    sweeps, triggerType, triggerSource, extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)
                    
            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenPropertiesArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenPropertiesArbitrary: Conflict between the shots and sweeps parameters sent to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenPropertiesArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenPropertiesArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenPropertiesArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenPropertiesArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenPropertiesArbitrary: Unable to setup signal generator waveform.');
                    
                case PicoStatus.PICO_SIGGEN_INVALID_SWEEP_PARAMETERS
                    
                    error('setSigGenPropertiesArbitrary: The sweeps or shots and trigger type are not valid when combined together.');
                    
                otherwise     
                    
                    error('setSigGenPropertiesArbitrary: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
            end
            
        end
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenPropertiesArbitrary(obj, increment, dwellTime, arbitraryWaveformSize, sweepType, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV)  reprograms the arbitrary waveform generator. All values can be reprogrammed while the oscilloscope is waiting for a trigger.

The startFrequency and stopFrequency properties must be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input arguments:

obj - the object representing the Signalgenerator group.
increment - the increase or decrease in frequency (in hertz) when operating in sweep mode.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
arbitraryWaveformSize -  the length of the arbitrary waveform buffer, in samples.
sweepType - determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
indexMode - specifies how the signal will be formed from the arbitrary waveform data.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
	then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - used to set the trigger level for the external trigger (in millivolts).

Output arguments:

status - status code returned by the driver.
dwellTime - the dwell time will be modified if the user specifies a dwell time corresponding to less than the minimum dwell count for the device (3).</Description>
            </Method>
            <Method>
               <Name>setSigGenPropertiesBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenPropertiesBuiltIn(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    sigGenType = deviceObj.DriverData.sigGenType;
    
    % Error checking
    if (sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert extInThresholdMV to counts if device is not an MSO model
        extInThreshold = 0;
        
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS5000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS5000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps5000a', 'ps5000aSetSigGenPropertiesBuiltIn', ...
                    deviceObj.DriverData.unitHandle, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.stopFrequency, ...
                    increment, dwellTime, sweepType, shots, sweeps, ...
                    triggerType, triggerSource, extInThreshold);

        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)

            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenPropertiesBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenPropertiesBuiltIn: Conflict between the shots and sweeps parameters sent to the signal generator.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenPropertiesBuiltIn: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenPropertiesBuiltIn: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenPropertiesBuiltIn: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenPropertiesBuiltIn: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenPropertiesBuiltIn: Unable to setup signal generator waveform.');

                case PicoStatus.PICO_SIGGEN_INVALID_SWEEP_PARAMETERS
                    
                    error('setSigGenPropertiesBuiltIn: The sweeps or shots and trigger type are not valid when combined together.');
                      
                otherwise     

                    error('setSigGenPropertiesBuiltIn: Status code: %d. Please refer to the PicoStatus.m file.\n', dec2hex(status));
            end

        end
                
    else
        
        error('setSigGenPropertiesBuiltIn: Signal Generator functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenPropertiesBuiltIn(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV) sets up the signal generator to produce a signal from a list of built-in waveforms.

The startFrequency and stopFrequency properties must be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
increment - the amount in hertz by which the frequency rises or falls every dwellTime seconds in sweep mode.
dwellTime - the time in seconds between frequency changes in sweep mode.
sweepType - determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
              then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - used to set the trigger level for the external trigger (in millivolts).

Output arguments:

status - status code returned by the driver.

</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>streaming</Name>
         <Description>The Signalgenerator group contains a set of properties and functions related to the signal generator functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Streaming1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoStop</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.autoStop;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.autoStop = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A flag to specify if streaming data collection should stop when the sum of pre-trigger and post-trigger samples have been taken.

This flag should be set to 0 or 1.</Description>
            </Property>
            <Property>
               <Name>streamingInterval</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.streamingInterval;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.streamingInterval = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The requested time interval between samples (in seconds) when capturing data in streaming mode.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>autoStopped</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function autoStop = autoStopped(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    autoStop = calllib('ps5000aWrap', 'AutoStopped', deviceObj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>AutoStopped(obj) indicates if the device has stopped on collection of the number of samples specified in the call to the ps5000aRunStreaming function.

The autoStop property must have been set to 1.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

autoStop - 0 if the device has not stopped, non-zero if streaming has auto-stopped.</Description>
            </Method>
            <Method>
               <Name>availableData</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, startIndex] = availableData(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pStartIndex = libpointer('uint32Ptr', 0);

    [numSamples, ~] = calllib('ps5000aWrap', 'AvailableData', ...
                                deviceObj.DriverData.unitHandle, pStartIndex);
                            
    startIndex = pStartIndex.Value;</MCode>
               </Code>
               <Description>AvailableData(obj) indicates the number of samples returned from the driver and shows the start index of the data in the buffer when collecting data in streaming mode.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

numSamples - 0, data is not yet available; Non-zero, the number of samples returned from the driver.
startIndex - an index to the first valid sample in the buffer (when data is available).

Note: the startIndex value is zero-based so should be incremented by 1 when used to retrieve data from the arrays defined in your MATLAB scripts.
</Description>
            </Method>
            <Method>
               <Name>clearTriggerReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function triggerCleared = clearTriggerReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    triggerCleared = calllib('ps5000aWrap', 'ClearTriggerReady', deviceObj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>ClearTriggerReady(obj) clears the triggered and triggeredAt flags in relation to streaming mode capture.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

1 - Call successfully completed.</Description>
            </Method>
            <Method>
               <Name>getStreamingLatestValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = getStreamingLatestValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps5000aWrap', 'GetStreamingLatestValues', ...
                deviceObj.DriverData.unitHandle);
            
    if (status ~= PicoStatus.PICO_OK &amp;&amp; status ~= PicoStatus.PICO_BUSY)
           
        error('getStreamingLatestValues: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>GetStreamingLatestValues(obj) facilitates communication with the underlying driver to return the next block of values to your application when capturing data in streaming mode.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>isReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function ready = isReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    ready = calllib('ps5000aWrap', 'IsReady', deviceObj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>IsReady(obj) is used to poll the driver to verify that data is ready to be received. Use ps5000aRunStreaming function must have been called prior to calling this function.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

ready - 0, if data is not yet available; non-zero if data is ready to be collected.

</Description>
            </Method>
            <Method>
               <Name>isTriggerReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [triggered, triggeredAt] = isTriggerReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pTriggeredAt = libpointer('uint32Ptr', 0);

    [triggered, ~] = calllib('ps5000aWrap', 'IsTriggerReady', ...
        deviceObj.DriverData.unitHandle, pTriggeredAt);
    
    triggeredAt = pTriggeredAt.Value;</MCode>
               </Code>
               <Description>IsTriggerReady(obj) indicates whether a trigger has occurred when collecting data in streaming mode, and the location of the trigger point.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

triggered - 0, if the device has not triggered; Non-zero, if the device has been triggered.
triggeredAt - the zero-based index of the sample in the buffer where the trigger occurred.


</Description>
            </Method>
            <Method>
               <Name>ps5000aNoOfStreamingValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, noOfValues] = ps5000aNoOfStreamingValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNoOfValues = libpointer('uint32Ptr', 0);

    [status, noOfValues] = calllib('ps5000a', 'ps5000aNoOfStreamingValues', ...
        deviceObj.DriverData.unitHandle, pNoOfValues);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aNoOfStreamingValues: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end
    
    noOfValues = pNoOfValues.Value;</MCode>
               </Code>
               <Description>ps5000aNoOfStreamingValues(obj) returns the number of samples available after data collection in streaming mode. Call this function after calling ps5000aStop.

Input arguments:

obj - the object representing the Streaming group object.

Output arguments:

status - status code returned by the driver.
noOfValues - the number of samples.</Description>
            </Method>
            <Method>
               <Name>ps5000aRunStreaming</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleInterval, sampleIntervalTimeUnitsStr] = ps5000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Calculate sampleInterval and sampleIntervalTimeUnits according to
    % streamingInterval property set. Property is defined in seconds.

    streamingInterval = deviceObj.DriverData.streamingInterval; 
    
    femtosecondsEnum    = deviceObj.DriverData.enums.enPS5000ATimeUnits.PS5000A_FS;
    picosecondsEnum     = deviceObj.DriverData.enums.enPS5000ATimeUnits.PS5000A_PS;
    nanosecondsEnum     = deviceObj.DriverData.enums.enPS5000ATimeUnits.PS5000A_NS;
    microsecondsEnum    = deviceObj.DriverData.enums.enPS5000ATimeUnits.PS5000A_US;
    millisecondsEnum    = deviceObj.DriverData.enums.enPS5000ATimeUnits.PS5000A_MS;
    secondsEnum         = deviceObj.DriverData.enums.enPS5000ATimeUnits.PS5000A_S;
    
    sampleIntervalTimeUnits = secondsEnum;
    
    % Match the specified interval to the correct time units
    % If an interval with component less than the minimum value for the time unit 
    % is specified e.g 1.3e-3, that will be converted to 1300 microseconds.
    
    if (streamingInterval &lt; 1e-12) % Femtoseconds (unlikely with USB 2.0)
        
        sampleInterval = streamingInterval * 1e15;
        sampleIntervalTimeUnits = femtosecondsEnum;
        
    elseif (streamingInterval &gt;= 1e-12 &amp;&amp; streamingInterval &lt; 1e-9) % Picoseconds
        
        if (mod(streamingInterval, 1e-12) &gt; 0)
           
            sampleInterval = streamingInterval * 1e15;
            sampleIntervalTimeUnits = femtosecondsEnum;
            
        else
            
            sampleInterval = streamingInterval * 1e12;
            sampleIntervalTimeUnits = picosecondsEnum;
            
        end
        
    elseif (streamingInterval &gt;= 1e-9 &amp;&amp; streamingInterval &lt; 1e-6) % Nanoseconds
        
        if (mod(streamingInterval, 1e-9) &gt; 0)
           
            sampleInterval = streamingInterval * 1e12;
            sampleIntervalTimeUnits = picosecondsEnum;
            
        else
        
            sampleInterval = streamingInterval * 1e9;
            sampleIntervalTimeUnits = nanosecondsEnum;
            
        end
        
    elseif (streamingInterval &gt;= 1e-6 &amp;&amp; streamingInterval &lt; 1e-3) % Microseconds
        
        if (mod(streamingInterval, 1e-6) &gt; 0)
            
            sampleInterval = streamingInterval * 1e9;
            sampleIntervalTimeUnits = nanosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e6;
            sampleIntervalTimeUnits = microsecondsEnum;
            
        end
        
    elseif (streamingInterval &gt;= 1e-3 &amp;&amp; streamingInterval &lt; 1) % Milliseconds
        
        if (mod(streamingInterval, 1e-3) &gt; 0)
            
            sampleInterval = streamingInterval * 1e6;
            sampleIntervalTimeUnits = microsecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e3;
            sampleIntervalTimeUnits = millisecondsEnum;
            
        end
            
    else 
        
        % Already defined seconds
        
        if (mod(streamingInterval, 1) &gt; 0)
           
           sampleInterval = streamingInterval * 1e3;
           sampleIntervalTimeUnits = millisecondsEnum;
           
       end
        
    end
            
    [status, sampleInterval] = calllib('ps5000a', 'ps5000aRunStreaming', ...
        deviceObj.DriverData.unitHandle, sampleInterval, sampleIntervalTimeUnits, ...
        deviceObj.DriverData.numPreTriggerSamples, deviceObj.DriverData.numPostTriggerSamples, ...
        deviceObj.DriverData.autoStop, downSampleRatio, downSampleRatioMode, overviewBufferSize);
    
    if (status == PicoStatus.PICO_OK)
        
        switch(sampleIntervalTimeUnits)
       
            case femtosecondsEnum

                sampleIntervalTimeUnitsStr = 'fs';
                
            case picosecondsEnum

                sampleIntervalTimeUnitsStr = 'ps';

            case nanosecondsEnum

                sampleIntervalTimeUnitsStr = 'ns';

            case microsecondsEnum

                sampleIntervalTimeUnitsStr = 'us';

            case millisecondsEnum

                sampleIntervalTimeUnitsStr = 'ms';

            case secondsEnum

                sampleIntervalTimeUnitsStr = 's';
            
            otherwise
                
                % Do nothing
        
        end
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('ps5000aRunStreaming:- Sample interval %d %s\n', sampleInterval, ...
                sampleIntervalTimeUnitsStr);
            
        end
        
    % Check for Power connection
    elseif (status == PicoStatus.PICO_POWER_SUPPLY_CONNECTED || ...
                status == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED || ...
                status == PicoStatus.PICO_POWER_SUPPLY_UNDERVOLTAGE)
    
        status = invoke(deviceObj, 'ps5000aChangePowerSource', status)
        
    else
        
        error('ps5000aRunStreaming: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize) tells the oscilloscope to start collecting data in streaming mode. Use thefunction getStreamingLatestValues to obtain the values. 

Input arguments:

obj - the object representing the Streaming group object.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode -  which downsampling mode to use (an enumeration from the enPS5000ARatioMode range).
overviewBufferSize - the size of the overview buffers (temporary buffers used for storing the data before returning it to the application).

Output arguments:

status - status code returned by the driver.
sampleInterval - the actual time interval used.
sampleIntervalTimeUnitsStr - a string representing the time unit for the sampling interval.

</Description>
            </Method>
            <Method>
               <Name>setAppAndDriverBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    status = calllib('ps5000aWrap', 'setAppAndDriverBuffers', ...
        deviceObj.DriverData.unitHandle, channel, appBuffer, driverBuffer, bufferLength);
    
    if (status ~= PicoStatus.PICO_OK)
       
        error('setAppAndDriverBuffers: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength) set the application and corresponding driver buffer in the wrapper shared library.

This function is required to allow the driver to copy the data into the application buffer being used in MATLAB when acquiring data from the PicoScope in streaming mode without aggregation.

Input arguments:

obj - the object representing the Streaming group object.
channel - the channel or digital port to which the buffers correspond (an enumeration from the enPS5000AChannel range).
appBuffer - a libpointer to a 1-D array representing the application buffer.
driverBuffer - the libpointer passed to the driver in the ps5000aSetDataBuffer function call.
bufferLength - the length of the arrays (must be equal)

Output arguments:

status - status code returned by the wrapper.</Description>
            </Method>
            <Method>
               <Name>setMaxMinAppAndDriverBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setMaxMinAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    status = calllib('ps5000aWrap', 'setMaxMinAppAndDriverBuffers', ...
        deviceObj.DriverData.unitHandle, channel, appMaxBuffer, appMinBuffer, ...
        driverMaxBuffer, driverMinBuffer, bufferLength);
    
    if (status ~= PicoStatus.PICO_OK)
       
        error('setMaxMinAppAndDriverBuffers: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength) set the maximum and minimum application and corresponding driver buffers in the wrapper shared library.

This function is required to allow the driver to copy the data into the maximum and minimum application buffers being used in MATLAB when acquiring data from the PicoScope in  streaming mode with aggregation.

Input arguments:

obj - the object representing the Streaming group object.
 the channel or digital port to which the buffers correspond (an enumeration from the enPS5000AChannel range).
appMaxBuffer - a libpointer to a 1-D array representing the application buffer for maximum values.
appMinBuffer - a libpointer to a 1-D array representing the application buffer for minimum values.
driverMaxBuffer - the libpointer passed to the driver for the maximum aggregated data values  in the ps5000aSetDataBuffers() function call.
driverMinBuffer - the libpointer passed to the driver for the minimum aggregated data values in the ps5000aSetDataBuffers() function call.
bufferLength - the length of the arrays (must be equal)

Output arguments:

status - status code returned by the wrapper.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>trigger</Name>
         <Description>The Trigger group contains a set of properties and functions related to the trigger functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Trigger1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoTriggerMs</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent'); 
    propertyValue = deviceObj.DriverData.autoTriggerMs;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.autoTriggerMs = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of milliseconds the device will wait if no trigger occurs. If this is set to zero, the scope device will wait indefinitely for a trigger.

This property will only be used with setSimpleTrigger().</Description>
            </Property>
            <Property>
               <Name>delay</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.delay;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.delay = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The time, in sample periods, between the trigger occurring and the first sample being taken.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps5000aGetTriggerTimeOffset</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeUpper, timeLower, timeUnits] = ps5000aGetTriggerTimeOffset(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pTimeUpper = libpointer('uint32Ptr', 0);
    pTimeLower = libpointer('uint32Ptr', 0);
    pTimeUnits = libpointer('enPS5000ATimeUnits', obj.DriverData.enums.enPS5000ATimeUnits.PS5000A_FS);
    
    [status, ~, ~, ~] = calllib('ps5000a', ...
        'ps5000aGetTriggerTimeOffset', deviceObj.DriverData.unitHandle, ...
        pTimeUpper, pTimeLower, pTimeUnits, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetTriggerTimeOffset:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    else
        
        timeUpper = pTimeUpper.Value;
        timeLower = pTimeLower.Value;
        timeUnits = pTimeUnits.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetTriggerTimeOffset(obj, segmentIndex) gets the time, as two 4-byte values, at which the trigger occurred.

A data capture must have been made prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
segmentIndex - the number of the memory segment for which the information is required.

Output parameters:

status - status code returned by the driver.
timeUpper - the upper 32 bits of the time at which the trigger point occurred.
timeLower - the lower 32 bits of the time at which the trigger point occurred.
timeUnits - the time units in which timeUpper and timeLower are measured (an enPS5000ATimeUnits enumeration).</Description>
            </Method>
            <Method>
               <Name>ps5000aGetTriggerTimeOffset64</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, time, timeUnits] = ps5000aGetTriggerTimeOffset64(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pTime = libpointer('int64Ptr', 0);
    pTimeUnits = libpointer('enPS5000ATimeUnits', obj.DriverData.enums.enPS5000ATimeUnits.PS5000A_FS);

    [status, ~] = calllib('ps5000a', ...
        'ps5000aGetTriggerTimeOffset64', deviceObj.DriverData.unitHandle, pTime, ...
        pTimeUnits, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetTriggerTimeOffset64:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    else
        
        time = pTime.Value;
        timeUnits = pTimeUnits.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetTriggerTimeOffset64(obj, segmentIndex)  gets the time, as a single 64-bit value, at which the trigger occurred.

A data capture must have been made prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
segmentIndex -  the number of the memory segment for which the information is required.

Output parameters:

status - status code returned by the driver.
time - the time at which the trigger point occurred.
timeUnits - the time units in which time is measured (an enPS5000ATimeUnits enumeration).

</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesTriggerTimeOffsetBulk</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timesUpper, timesLower, timeUnits] = ps5000aGetValuesTriggerTimeOffsetBulk(obj, fromSegmentIndex, toSegmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Define the length of the arrays to be used for capturing time
    % information
    timesArraySize = (toSegmentIndex - fromSegmentIndex) + 1;
    
    pTimesUpper = libpointer('uint32Ptr', zeros(timesArraySize, 1));
    pTimesLower = libpointer('uint32Ptr', zeros(timesArraySize, 1));
    pTimeUnits = libpointer('uint32Ptr', zeros(timesArraySize, 1));

    [status, ~, ~, ~] = ...
        calllib('ps5000a', 'ps5000aGetValuesTriggerTimeOffsetBulk', ...
        deviceObj.DriverData.unitHandle, pTimesUpper, pTimesLower, pTimeUnits, ...
        fromSegmentIndex, toSegmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetValuesTriggerTimeOffsetBulk:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    else
        
        timesUpper = pTimesUpper.Value;
        timesLower = pTimesLower.Value;
        timeUnits = pTimeUnits.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesTriggerTimeOffsetBulk(obj, fromSegmentIndex, toSegmentIndex) retrieves the time offsets, as lower and upper 32-bit values, for waveforms obtained in rapid block mode.

A rapid block data capture must have been made prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
fromSegmentIndex - the first segment for which the time offset is required.
toSegmentIndex - the last segment for which the time offset is required.

Output parameters:

status - status code returned by the driver.
timesUpper - an array of integers containing the most significant 32 bits of the time offset for each requested segment index.
timesLower - an array of integers containing the least significant 32 bits of the time offset for each requested segment index.
timeUnits - an array of integers representing the time unit for each time entry (an enPS5000ATimeUnits enumeration).</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesTriggerTimeOffsetBulk64</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, times, timeUnits] = ps5000aGetValuesTriggerTimeOffsetBulk64(obj, fromSegmentIndex, toSegmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Define the length of the arrays to be used for capturing time
    % information
    timesArraySize = (toSegmentIndex - fromSegmentIndex) + 1;
    
    pTimes = libpointer('int64Ptr', zeros(timesArraySize, 1));
    pTimeUnits = libpointer('uint32Ptr', zeros(timesArraySize, 1));

    [status, ~, ~] = calllib('ps5000a', ...
        'ps5000aGetValuesTriggerTimeOffsetBulk64', deviceObj.DriverData.unitHandle, ...
        pTimes, pTimeUnits, fromSegmentIndex, toSegmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aGetValuesTriggerTimeOffsetBulk64:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    else
        
        times = pTimes.Value;
        timeUnits = pTimeUnits.Value;
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesTriggerTimeOffsetBulk64(obj, fromSegmentIndex, toSegmentIndex) retrieves the 64-bit time offsets for waveforms captured in rapid block mode.

A rapid block data capture must have been made prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
fromSegmentIndex - the first segment for which the time offset is required.
toSegmentIndex - the last segment for which the time offset is required.

Output parameters:

status - status code returned by the driver.
times - an array of integers holding the time offset for each requested segment index.
timeUnits - an array of integers representing the time unit for each time entry (an enPS5000ATimeUnits enumeration).</Description>
            </Method>
            <Method>
               <Name>ps5000aIsTriggerOrPulseWidthQualifierEnabled</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, triggerEnabled, pwqEnabled] = ps5000aIsTriggerOrPulseWidthQualifierEnabled(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Allocate values for variables
    pTriggerEnabled = libpointer('int16Ptr', 0);
    pPwqEnabled = libpointer('int16Ptr', 0);

    [status, ~, ~] = calllib('ps5000a', 'ps5000aIsTriggerOrPulseWidthQualifierEnabled', ...
        deviceObj.DriverData.unitHandle, pTriggerEnabled, pPwqEnabled);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aIsTriggerOrPulseWidthQualifierEnabled:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
    
    triggerEnabled = pTriggerEnabled.Value; 
    pwqEnabled = pPwqEnabled.Value;</MCode>
               </Code>
               <Description>ps5000aIsTriggerOrPulseWidthQualifierEnabled(obj) discovers whether a trigger, or pulse width triggering, is enabled.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.

Output parameters:

status - status code returned by the device.
triggerEnabled - indicates if trigger is set.
pwqEnabled - indicates if pulse width qualifier is set.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetAutoTriggerMicroSeconds</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetAutoTriggerMicroSeconds(obj, autoTriggerMicroseconds)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    validateattributes(autoTriggerMicroseconds, {'numeric'}, {'scalar', 'integer', 'nonnegative'});
    
    status = calllib('ps5000a', 'ps5000aSetAutoTriggerMicroSeconds', ...
        deviceObj.DriverData.unitHandle, uint64(autoTriggerMicroseconds));
    
    if (status ~= PicoStatus.PICO_OK)
        
        error('Picotech:PS5000AInstrumentDriver:ps5000aSetAutoTriggerMicroSeconds', ...
                    ['ps5000aSetAutoTriggerMicroSeconds has returned status code ', ...
                    num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
                
    end</MCode>
               </Code>
               <Description>ps5000aSetAutoTriggerMicroSeconds(obj, autoTriggerMicroseconds) sets up the auto-trigger function which starts a capture if no trigger event occurs within
a specified time after a ps5000aRunBlock, runBlock or ps5000aRunStreaming command has been issued.

Input parameters:

obj - the object representing the Trigger group.
autoTriggerMicroseconds - the number of microseconds for which the scope device will wait for a trigger before timing out. If this argument is zero, the scope device will wait indefinitely for a trigger.

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetAutoTriggerMicroSeconds function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetPulseWidthQualifier</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetPulseWidthQualifier(obj, conditions, nConditions, direction, lower, upper, type)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    maxPwqConditions = deviceObj.DriverData.constants.MAX_PULSE_WIDTH_QUALIFIER_COUNT;
    
    % Verify number of conditions is set correctly
    if (nConditions &gt; 0 &amp;&amp; nConditions &lt;= maxPwqConditions)
            
        status = calllib('ps5000a', 'ps5000aSetPulseWidthQualifier', ...
            deviceObj.DriverData.unitHandle, conditions, nConditions, direction, lower, ...
            upper, type)
        
    else
       
        error('ps5000aSetPulseWidthQualifier: Number of PWQ conditions must be between 0 and %d', maxPwqConditions);
        
    end
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetPulseWidthQualifier:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetPulseWidthQualifier(obj, conditions, nConditions, direction, lower, upper, type) sets up pulse-width qualification, which can be used on its own for pulse width triggering or combined with window triggering to produce more complex triggers.

If using the Test and Measurement Tool, please use setPulseWidthQualifier.

Input parameters:

obj - the object representing the Trigger group.
pwqConditions -  an array of tPS5000APwqConditions structures specifying the conditions that should be applied to each channel.
nConditions - the number of elements in the conditions array.
direction - the direction of the signal required for the pulse width trigger to fire (an enPS5000AThresholdDirection enumeration).
lower - the lower limit of the pulse-width counter with relation to number of samples captured on the device.
upper - the upper limit of the pulse-width counter with relation to number of samples captured on the device.
type - the pulse-width type (an enPS5000APulseWidthType enumeration).

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetPulseWidthQualifier function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetPulseWidthQualifierConditions</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetPulseWidthQualifierConditions(obj, conditions, nConditions, info)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Create a libpointer object for the conditions structure
    pConditions = libpointer('tPS5000AConditionPtr', conditions);
    
    status = calllib('ps5000a', 'ps5000aSetPulseWidthQualifierConditions',deviceObj.DriverData.unitHandle, ...
                    pConditions, nConditions, info);
                
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetPulseWidthQualifierConditions:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end </MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>ps5000aSetPulseWidthQualifierDirections</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetPulseWidthQualifierDirections(obj, directions, nDirections)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Create a libpointer object for the directions structure
    pDirections = libpointer('tPS5000ADirectionPtr', directions);
    
    status = calllib('ps5000a','ps5000aSetPulseWidthQualifierDirections',deviceObj.DriverData.unitHandle,...
                        pDirections,nDirections);
                    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetPulseWidthQualifierDirections:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end </MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>ps5000aSetPulseWidthQualifierProperties</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetPulseWidthQualifierProperties(obj, lower, upper, type)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
        
    deviceObj = get(obj, 'Parent');
        
    status = calllib('ps5000a', 'ps5000aSetPulseWidthQualifierProperties', deviceObj.DriverData.unitHandle, ... 
                            lower, upper, type);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetPulseWidthQualifierProperties:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end </MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>ps5000aSetTriggerChannelConditionsV2</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetTriggerChannelConditionsV2(obj, conditions, info)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (isstruct(conditions) || isempty(conditions))
        
        deviceObj = get(obj, 'Parent');

        % Create a libpointer object for the conditions structure
        pConditions = libpointer('tPS5000AConditionPtr', conditions);

        status = calllib('ps5000a', 'ps5000aSetTriggerChannelConditionsV2', ...
                    deviceObj.DriverData.unitHandle, pConditions, ...
                    length(conditions), int16(info));

        if (status ~= PicoStatus.PICO_OK)
 
            error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelConditionsV2Error', ...
                ['ps5000aSetTriggerChannelConditionsV2 has returned status code ', ...
                num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
            
        end
        
    else

        error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelConditionsV2InvalidConditions', ...
                ['ps5000aSetTriggerChannelConditionsV2: conditions input ',...
                'argument should be a tPS5000ACondition structure or empty matrix.']);

    end
    </MCode>
               </Code>
               <Description>ps5000aSetTriggerChannelConditionsV2(obj, conditions, info) specifies which channels to trigger on.

If you only need to trigger on a single analog input with edge or level detection, it's easier to use
setSimpleTrigger. 

Input parameters:

obj - the object representing the Trigger group object.
conditions - a structure array consisting of 1 or more MATLAB structures corresponding to the tPS5000ACondition structure (accessible from the ps5000aStructs struct).
info - refer to the main Programmer's Guide (see below)

Output  parameters:

status - status code returned by the device.

Please refer to the ps5000aSetTriggerChannelConditionsV2 function in the PicoScope 5000 Series (A API) Flexible Resolution Oscilloscopes Programmer's Guide for further information.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetTriggerChannelDirections</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetTriggerChannelDirections(obj, channelA, channelB, channelC, channelD, ext)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    warning('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelDirectionsFunctionDeprecated', ...
                ['ps5000aSetTriggerChannelDirections is now deprecated - ',...
                'please use ps5000aSetTriggerChannelDirectionsV2 instead if not using '...
                'Test and Measurement Tool'.']);

    deviceObj = get(obj, 'Parent');

    % Aux parameter not used.
    aux = 0;
    
    status = calllib('ps5000a', 'ps5000aSetTriggerChannelDirections', ...
        deviceObj.DriverData.unitHandle, channelA, channelB, channelC, channelD, ext, aux);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetTriggerChannelDirections:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end </MCode>
               </Code>
               <Description>ps5000aSetTriggerChannelDirections(obj, channelA, channelB, channelC, channelD, ext) sets the direction of the trigger for each channel.

This function may be used with the Test and Measurement Tool.

NOTE: This function is now deprecated - please use ps5000aSetTriggerChannelDirectionsV2 instead if not using Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
channelA, channelB,channelC, channelD, ext - the direction in which the signal must pass through the threshold to activate the trigger (an enumeration from the enPS5000AThresholdDirection range).

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetTriggerChannelDirections function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetTriggerChannelDirectionsV2</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetTriggerChannelDirectionsV2(obj, directions)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (isstruct(directions) || isempty(directions))
        
        deviceObj = get(obj, 'Parent');

        % Create a libpointer object for the directions structure
        pDirections = libpointer('tPS5000ADirectionPtr', directions);

        status = calllib('ps5000a', 'ps5000aSetTriggerChannelDirectionsV2', ...
            deviceObj.DriverData.unitHandle, pDirections, uint16(length(directions)));

        if (status ~= PicoStatus.PICO_OK)

            error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelDirectionsV2Error', ...
                ['ps5000aSetTriggerChannelDirectionsV2 has returned status code ', ...
                num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);

        end
        
    else
       
        error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelDirectionsV2InvalidDirections', ...
                ['ps5000aSetTriggerChannelDirectionsV2: directions input ',...
                'argument should be a tPS5000ADirection structure or empty matrix.']);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetTriggerChannelDirectionsV2(obj, directions) sets up signal polarities for triggering.

This function applies to analog channels only (use ps5000aSetTriggerDigitalPortProperties for digital channels). 

Input parameters:

obj - the object representing the Trigger group object.
directions - a structure array consisting of 1 or more MATLAB structures corresponding to the tPS5000ADirection structure (accessible from the ps5000aStructs struct).

Output  parameters:

status - status code returned by the device.

Please refer to the ps5000aSetTriggerChannelDirectionsV2 function in the PicoScope 5000 Series (A API) Flexible Resolution Oscilloscopes Programmer's Guide for further information.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetTriggerChannelPropertiesV2</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetTriggerChannelPropertiesV2(obj, channelProperties)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (isstruct(channelProperties) || isempty(channelProperties))
        
        deviceObj = get(obj, 'Parent');
        
        channelPropertiesLength = length(channelProperties);
        
        if (channelPropertiesLength &gt; 0)
            
            channelProperties = invoke(obj, 'triggerChannelPropertiesConversion', channelProperties);
            
        end
        
        % Create a libpointer object for the channelProperties structure
        pChannelProperties = libpointer('tPS5000ATriggerChannelPropertiesV2Ptr', channelProperties);
        auxOutputEnable = 0;
        
        status = calllib('ps5000a', 'ps5000aSetTriggerChannelPropertiesV2', ...
            deviceObj.DriverData.unitHandle, pChannelProperties, int16(channelPropertiesLength), auxOutputEnable);
        
        if (status ~= PicoStatus.PICO_OK)
            
            error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelPropertiesV2', ...
                    ['ps5000aSetTriggerChannelPropertiesV2 has returned status code ', ...
                    num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
        
        end
        
    else
        
        error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerChannelPropertiesV2InvalidProperties', ...
                ['ps5000aSetTriggerChannelPropertiesV2: channelProperties input ',...
                'argument should be a tPS5000ATriggerChannelPropertiesV2 structure or empty matrix.']);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetTriggerChannelPropertiesV2(obj, channelProperties) n is used to enable or disable triggering on the analog channels and set its parameters.

This function applies to analog channels only (use ps5000aSetTriggerDigitalPortProperties for digital channels). 

Input parameters:

obj - the object representing the Trigger group object.
channelProperties - a structure array consisting of 1 or more MATLAB structures corresponding to the tPS5000ATriggerChannelPropertiesV2 structure (accessible from the ps5000aStructs struct) with the threshold and hysteresis levels specified in millivolts.

Output  parameters:

status - status code returned by the device.

Please refer to the ps5000aSetTriggerChannelPropertiesV2 function in the PicoScope 5000 Series (A API) Flexible Resolution Oscilloscopes Programmer's Guide for further information.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetTriggerDigitalPortProperties</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetTriggerDigitalPortProperties(obj, digitalDirections)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.


    if (isstruct(digitalDirections) || isempty(digitalDirections))
        
        deviceObj = get(obj, 'Parent');
        
        digitalDirectionsLength = length(digitalDirections);
        
        deviceObj = get(obj, 'Parent');

        status = calllib('ps5000a', 'ps5000aSetTriggerDigitalPortProperties', ...
            deviceObj.unitHandle, digitalDirections, digitalDirectionsLength);
 
        if (status ~= PicoStatus.PICO_OK)
           
            error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerDigitalPortProperties', ...
                    ['ps5000aSetTriggerDigitalPortProperties has returned status code ', ...
                    num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
                
        end 
        
    else
        
        error('Picotech:PS5000AInstrumentDriver:ps5000aSetTriggerDigitalPortPropertiesInvalidProperties', ...
                ['ps5000aSetTriggerDigitalPortProperties: channelProperties input ',...
                'argument should be a tPS5000ATriggerDigitalPortProperties structure or empty matrix.']);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetTriggerDigitalPortProperties(obj, digitalDirections) sets the direction of the trigger for digital channels.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
digitalDirections - a structure containing directions for digital channels

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetTriggerDigitalPortPropertiess function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setAdvancedTrigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function advTrigStatus = setAdvancedTrigger(obj, channelProperties, triggerConditions, directions)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    warning('Picotech:PS5000AInstrumentDriver:setAdvancedTriggerFunctionDeprecated', ...
                ['setAdvancedTrigger is now deprecated - ',...
                'please use the appropriate functions from the Trigger group instead.']);

    deviceObj = get(obj, 'Parent');
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('setAdvancedTrigger: Number of channelProperties elements: %d\n', length(channelProperties));

    end
    
    % Set the trigger channel properties
    % No aux output so set to 0
    advTrigStatus.setProperties = calllib('ps5000a', ...
        'ps5000aSetTriggerChannelProperties', deviceObj.DriverData.unitHandle, ...
        channelProperties, length(channelProperties), 0, deviceObj.DriverData.autoTriggerMs);

    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('setAdvancedTrigger: Number of triggerConditions elements: %d\n', length(triggerConditions));
        
    end
    
    % Set trigger conditions
    advTrigStatus.setConditions = calllib('ps5000a', ...
        'ps5000aSetTriggerChannelConditions', deviceObj.DriverData.unitHandle, ...
        triggerConditions, length(triggerConditions));

    % Set directions
    advTrigStatus.setDirections = invoke(obj, 'ps5000aSetTriggerChannelDirections', ...
        directions.channelA, directions.channelB, directions.channelC, ...
        directions.channelD, directions.external, directions.aux);

    % Post trigger delay
    advTrigStatus.setTriggerDelay = calllib('ps5000a', ...
        'ps5000aSetTriggerDelay', deviceObj.DriverData.unitHandle, deviceObj.DriverData.delay);</MCode>
               </Code>
               <Description>setAdvancedTrigger(obj, channelProperties, triggerConditions, directions, delay, autoTriggerMs) sets the Advanced Trigger properties for the oscilloscope.

NOTE: This function is now deprecated - use the following functions as required:

* ps5000aSetTriggerChannelPropertiesV2
* ps5000aSetTriggerChannelConditionsV2
* ps5000aSetTriggerChannelDirectionsV2
* ps5000aSetPulseWidthQualifierProperties
* ps5000aSetPulseWidthQualifierConditions
* ps5000aSetPulseWidthQualifierDirections
</Description>
            </Method>
            <Method>
               <Name>setPulseWidthQualifier</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setPulseWidthQualifier(obj, pwqConditions, direction, lower, upper, type)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Determine if the number of sub-elements in the array is correct.
    % Find the number of elements in the structure and use this with the
    % length of the conditions array.
    pwqConditionsStruct = deviceObj.DriverData.structs.tPS5000APwqConditions.members;
    pwqConditionsElements = length(fieldnames(pwqConditionsStruct));
    
    % Length of array containing PWQ elements
    pwqLength = length(pwqConditions)
    
    if (mod(pwqLength, pwqConditionsElements) == 0)
        
        % Calculate the number of conditions
        numConditions = pwqLength / pwqConditionsElements;
        
        maxPwqConditions = deviceObj.DriverData.constants.MAX_PULSE_WIDTH_QUALIFIER_COUNT;
        
        if (numConditions &gt; 0 &amp;&amp; numConditions &lt;= maxPwqConditions)
        
            status = calllib('ps5000aWrap', 'SetPulseWidthQualifier', ...
                        deviceObj.DriverData.unitHandle, properties, numConditions, ...
                        direction, lower, upper, type);
                    
        else
           
            error('setPulseWidthQualifier: Number of PWQ conditions must be between 0 and %d', maxPwqConditions);
            
        end
        
    else
        
        error('setPulseWidthQualifier: Incorrect number of sub-elements in pwq conditions array. The array must be 1xN with %d sub-elements', pwqConditionsElements);
    
    end

    if (status ~= PicoStatus.PICO_OK)

        error('setPulseWidthQualifier:- status code: %d. Please refer to the PicoStatus.m file.', status); 

    end
    
    clear pwqConditionsStruct;
    clear pwqConditionsElements;
    clear pwqLength;
    clear numConditions;
    clear maxPwqConditions;</MCode>
               </Code>
               <Description>setPulseWidthQualifier(obj, pwqConditions, direction, lower, upper, type) 

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger object.
pwqConditions -  a 1-D array of n sub-arrays consisting of the elements in a tPS5000APwqConditions structure.
direction - the direction of the signal required for the pulse width trigger to fire (a enPS5000AThresholdDirection enumeration).
lower - the lower limit of the pulse-width counter with relation to number of samples captured on the device.
upper - the upper limit of the pulse-width counter with relation to number of samples captured on the device.
type - the pulse-width type (an enPS5000APulseWidthType).

Output parameters:

status - status code returned by the device.

For further information on the SetPulseWidthQualifier function please refer to the ps5000aSetPulseWidthQualifer function in the  PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSimpleTrigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSimpleTrigger(obj, source, thresholdMv, direction)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Find the voltage range index
    % Set default as 5 V (External trigger will use this range).
    channelRange = deviceObj.DriverData.enums.enPS5000ARange.PS5000A_5V;

    % Obtain information for device 
    channelSettings = deviceObj.DriverData.channelSettings;
    
    % Range is item 3 in the row for each channel

    switch (source)

        % Channel A
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A

            channelRange = channelSettings(1,3);

        % Channel B
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_B

            channelRange = channelSettings(2,3);

        % Channel C
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_C

            channelRange = channelSettings(3,3);

        % Channel D
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_D

            channelRange = channelSettings(4,3);
           
        % External trigger
        case deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_EXTERNAL
            
            % External trigger has ±5V range - no need to change.

        otherwise

            error('setSimpleTrigger: Invalid channel specified');

    end

    % Obtain the range being used in milliVolts
    channelRangeMv = PicoConstants.SCOPE_INPUT_RANGES(channelRange + 1);

    % Calculate the threshold in ADC counts
    thresholdAdc = mv2adc(thresholdMv, channelRangeMv, deviceObj.DriverData.maxADCValue);

    status = calllib('ps5000a', 'ps5000aSetSimpleTrigger', ...
            deviceObj.DriverData.unitHandle, PicoConstants.TRUE, source, thresholdAdc, ...
            direction, deviceObj.DriverData.delay, deviceObj.DriverData.autoTriggerMs);
        
    if (status ~= PicoStatus.PICO_OK)
           
        error('setSimpleTrigger:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>setSimpleTrigger(obj, source, threshold, direction, delay, autoTrigger_ms) simplifies arming the trigger. 

It supports only the LEVEL trigger types and does not allow more than one channel to have a trigger applied to it.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
source - the channel on which to trigger (an enumeration from the enPS5000AChannel range).
threshold - the voltage level (in millivolts) at which the trigger will fire.
direction - the direction in which the signal must move to cause a trigger (an enPS5000AThresholdDirection enumeration).

Output parameters:

status - status code returned by the device.

For further information on the setSimpleTrigger function please refer to the ps5000aSetSimpleTrigger function in the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setTriggerConditions</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerConditions(obj, conditions)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    warning('Picotech:PS5000AInstrumentDriver:setTriggerConditionsFunctionDeprecated', ...
                ['setTriggerConditions is now deprecated - ',...
                'please use ps5000aSetTriggerChannelConditionsV2 instead if not using '...
                'Test and Measurement Tool'.']);

    deviceObj = get(obj, 'Parent');

    % Determine if the number of sub-elements in the array is correct.
    % Find the number of elements in the structure and use this with the
    % length of the properties array.
    trigConditionsStruct = deviceObj.DriverData.structs.tPS5000ATriggerChannelProperties.members;
    trigConditionsElements = length(fieldnames(trigConditionsStruct));
    
    conditionsLength = length(conditions);
    
    if (mod(conditionsLength, trigConditionsElements) == 0)
        
        % Calculate number of sub-elements in array.
        numConditions = conditionsLength / trig_properties_elements;
        
        status = calllib('ps5000aWrap', 'SetTriggerConditions', ...
        deviceObj.DriverData.unitHandle, conditions, numConditions);
        
    else
        
        error('SetTriggerConditions: Incorrect number of sub-elements in conditions array. The array must be 1xN with %d sub-elements', trigConditionsElements);
    
    end
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('setTriggerConditions:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>SetTriggerConditions(obj, conditions) sets up trigger conditions on the scope's inputs.

This function may be used with the Test and Measurement Tool.

NOTE: This function is now deprecated - please use ps5000aSetTriggerChannelConditionsV2 instead if not using Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger object.
conditions - a 1-D array of n sub-arrays consisting of the elements in a tPS5000ATriggerChannelProperties structure.

Output parameters:

status - status code returned by the device.

For further information on the SetTriggerConditions function please refer to the ps5000aSetTriggerChannelConditions function in the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setTriggerOff</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Set trigger to false for channel A

    channel = deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A;
    direction = deviceObj.DriverData.enums.enPS5000AThresholdDirection.PS5000A_NONE;
    
    status = calllib('ps5000a', 'ps5000aSetSimpleTrigger', ...
            deviceObj.DriverData.unitHandle, PicoConstants.FALSE, channel, 0, direction, ...
            deviceObj.DriverData.delay, deviceObj.DriverData.autoTriggerMs);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('setTriggerOff: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>setTriggerOff(obj) switches off triggering on the oscilloscope.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.

Output parameters:

status - status code returned by the device.</Description>
            </Method>
            <Method>
               <Name>setTriggerProperties</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setTriggerProperties(obj, properties)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    warning('Picotech:PS5000AInstrumentDriver:setTriggerPropertiesFunctionDeprecated', ...
                ['setTriggerProperties is now deprecated - ',...
                'please use ps5000aSetTriggerChannelPropertiesV2 instead if not using '...
                'Test and Measurement Tool'.']);

    deviceObj = get(obj, 'Parent');

    % Determine if the number of sub-elements in the array is correct.
    % Find the number of elements in the structure and use this with the
    % length of the properties array.
    trigPropertiesStruct = deviceObj.DriverData.structs.tPS5000ATriggerChannelProperties.members;
    trigPropertiesElements = length(fieldnames(trigPropertiesStruct));
    
    propertiesLength = length(properties)
    
    if (mod(propertiesLength, trigPropertiesElements) == 0)
        
        numProperties = propertiesLength / trigPropertiesElements;
        
        status = calllib('ps5000aWrap', 'SetTriggerProperties', ...
                    deviceObj.DriverData.unitHandle, properties, numProperties, deviceObj.DriverData.autoTriggerMs);
        
    else
        
        error('SetTriggerProperties: Incorrect number of sub-elements in properties array. The array must be 1xN with %d sub-elements', trigPropertiesElements);
    
    end
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('setTriggerProperties: Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end</MCode>
               </Code>
               <Description>SetTriggerProperties(obj, properties, nProperties, autoTrig) sets the trigger properties for the device.

This function may be used with the Test and Measurement Tool in place of the ps5000aSetTriggerChannelProperties function called in the SetAdvancedTrigger function.

NOTE: This function is now deprecated - please use ps5000aSetTriggerChannelDirectionsV2 instead if not using Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
properties - a 1-D array of n sub-arrays consisting of the elements in a tPS5000ATriggerChannelProperties structure.

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetTriggerChannelProperties function and the TRIGGER_CHANNEL_PROPERTIES structure please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>triggerChannelPropertiesConversion</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function channelProperties = triggerChannelPropertiesConversion(obj, channelProperties)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    if (isstruct(channelProperties))
        
        numChannelProperties = length(channelProperties);

        % Convert the threshold and hysteresis values to ADC counts for
        % each property

        for n = 1:numChannelProperties

            vRange = 0; % millivolts
            maxADCValue = 0;

            if (channelProperties(n).channel &gt;= deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_CHANNEL_A &amp;&amp; ...
                        channelProperties(n).channel &lt; deviceObj.DriverData.channelCount)

                channelIndex = channelProperties(n).channel + 1; % Offset by 1 for the voltage range array
                vRange = PicoConstants.SCOPE_INPUT_RANGES(deviceObj.DriverData.channelSettings(channelIndex, 3) + 1);
                maxADCValue = deviceObj.DriverData.maxADCValue;

            elseif (channelProperties(n).channel == deviceObj.DriverData.enums.enPS5000AChannel.PS5000A_EXTERNAL)

                vRange = deviceObj.DriverData.constants.PS5000A_EXT_MAX_VOLTAGE * 1000; % convert to millivolts
                maxADCValue = deviceObj.DriverData.constants.PS5000A_EXT_MAX_VALUE;

            else

                error('Picotech:PS5000AInstrumentDriver:triggerChannelPropertiesConversion', ...
                ['triggerChannelPropertiesConversion: Invalid channel found in element ', num2str(n), ...
                ' of the channelProperties structure.']);

            end

            % Convert the data 
            channelProperties(n).thresholdUpper = mv2adc(channelProperties(n).thresholdUpper, vRange, maxADCValue);
            channelProperties(n).thresholdUpperHysteresis = mv2adc(channelProperties(n).thresholdUpperHysteresis, vRange, maxADCValue);
            channelProperties(n).thresholdLower = mv2adc(channelProperties(n).thresholdLower, vRange, maxADCValue);
            channelProperties(n).thresholdLowerHysteresis = mv2adc(channelProperties(n).thresholdLowerHysteresis, vRange, maxADCValue);

        end
        
    else
       
        error('Picotech:PS5000AInstrumentDriver:triggerChannelPropertiesConversion', ...
                ['triggerChannelPropertiesConversion: channelProperties input ',...
                'argument should be a tPS5000ATriggerChannelPropertiesV2 structure.']);
        
    end</MCode>
               </Code>
               <Description>triggerChannelPropertiesConversion(obj, channelProperties) converts the threshold and hysteresis values specified for a channel to ADC counts.

This function applies to analog channels only and is a helper function for the ps5000aSetTriggerChannelPropertiesV2 function. 

Input parameters:

obj - the object representing the Trigger group object.
channelProperties - a structure array consisting of 1 or more MATLAB structures corresponding to the tPS5000ATriggerChannelPropertiesV2 structure (accessible from the ps5000aStructs struct) with the threshold and hysteresis levels set to millivolts.

Output  parameters:

channelProperties - the structure passed as the input argument but with the threshold and hysteresis levels converted to ADC counts.

Please refer to the ps5000aSetTriggerChannelPropertiesV2 function for additional information.</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>